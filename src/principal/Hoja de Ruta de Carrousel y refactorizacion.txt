======================================================
  HOJA DE RUTA DEL PROYECTO (VISOR/CATALOGADOR)
======================================================

---
### PARTE 1: ARQUITECTURA GENERAL ###
---
- ESTADO: COMPLETADO
- ANÁLISIS: El patrón "Router/Dispatcher" con GeneralController como cerebro, y los componentes/acciones "tontos", está implementado. ActionFactory crea las acciones correctamente para notificar al GeneralController.

---
### PARTE 2: MODO CARRUSEL - FUNCIONALIDADES ###
---
2.1. Lógica de Listas y Contextos Independientes
    - ESTADO: COMPLETADO
    - ANÁLISIS: VisorModel tiene contextos separados (carouselListContext, visualizadorListContext). GeneralController implementa la lógica de "clonar solo la primera vez".

2.2. Barra de Herramientas y Controles Básicos (Play/Pause/Stop/FastMove)
    - ESTADO: COMPLETADO
    - ANÁLISIS: UIDefinitionService define la toolbar "carrousel". CarouselManager implementa la lógica de Play/Pause/Stop, ocultar/mostrar miniaturas y el avance/retroceso rápido con MouseListeners.

2.3. Contador Visual y Velocidad Básica
    - ESTADO: COMPLETADO
    - ANÁLISIS: CarouselManager gestiona el countdownTimer y actualiza el JLabel. La velocidad se lee desde el modelo, que la carga desde config.cfg.

======================================================
              TAREAS PENDIENTES
======================================================

---
### PARTE 3: MODO CARRUSEL - FUNCIONALIDADES AVANZADAS ###
---

3.1. Control de Velocidad Interactivo
    - FUNCIONALIDAD: Permitir al usuario cambiar la velocidad del carrusel durante la ejecución.
    - PLAN DE ACCIÓN:
        1. [ ] Crear `SetCarouselSpeedAction`: Nueva clase Action para manejar cambios de velocidad (ej. "2s", "3s", "Inverso -3s").
        2. [ ] Menú Emergente (Popup Menu): Modificar InfobarStatusManager para que el JLabel de velocidad reaccione a un clic, mostrando un JPopupMenu con las opciones.
        3. [ ] Actualización del Modelo: La Action seleccionada debe actualizar model.setCarouselDelay() y, opcionalmente, guardar el nuevo valor por defecto en config.cfg.
        4. [ ] Soporte Velocidad Negativa: Modificar el Timer en CarouselManager para que si el delay es negativo, llame a listCoordinator.seleccionarAnterior().

3.2. Lógica de Sincronización (Carrusel <-> Visualizador)
    - FUNCIONALIDAD: Implementar un modo "sincronizado" opcional entre el Carrusel y el Visualizador.
    - PLAN DE ACCIÓN:
        1. [ ] Añadir Opción de Configuración: Añadir clave en ConfigKeys (ej. CARRUSEL_MODO_SINCRONIZADO) y un JCheckBoxMenuItem en el menú para activarlo/desactivarlo.
        2. [ ] Refactorizar `GeneralController.salirModo()`: Implementar la lógica de sincronización al salir del Carrusel. Si el modo sincronizado está activo, clonar carouselListContext sobre visualizadorListContext.
        3. [ ] Refactorizar `GeneralController.entrarModo()`: Si el modo sincronizado está activo, forzar siempre la clonación desde el visualizador, ignorando el estado anterior del carrusel.

3.3. Funcionalidades Adicionales (Ideas)
    - FUNCIONALIDAD: Mejorar la usabilidad del modo carrusel.
    - PLAN DE ACCIÓN:
        1. [ ] Menú Contextual (Clic Derecho): Añadir MouseListener al ImageDisplayPanel del carrusel para mostrar un JPopupMenu con acciones ("Marcar para Proyecto", "Saltar a siguiente carpeta").
        2. [ ] Overlay de Texto (Nombre de Archivo): Añadir opción en menú "Vista". En ImageDisplayPanel, si la opción está activa, dibujar el nombre del archivo con fondo semitransparente en paintComponent.

---
### PARTE 4: ERRORES Y REFACTORIZACIÓN ###
---

4.1. BUG: Desincronización de Miniaturas (Visualizador)
    - SÍNTOMA: El selector de la JList de miniaturas a veces no se sincroniza con la lista de nombres.
    - CAUSA PROBABLE: Condiciones de carrera o cálculos de índice incorrectos en ListCoordinator.actualizarTiraDeMiniaturas().
    - PLAN DE SOLUCIÓN:
        1. [ ] Revisar y depurar el método `ListCoordinator.actualizarTiraDeMiniaturas()`, prestando atención al cálculo de `indiceRelativo` y la llamada a `sincronizarSeleccionJList()`.

4.2. BUG: Estado de Botones de Navegación del Carrusel
    - SÍNTOMA: Botones de navegación (Primera, Anterior, etc.) no se habilitan/deshabilitan correctamente en la barra del Carrusel.
    - CAUSA PROBABLE: Las Actions de navegación no se actualizan cuando el contexto activo es el del carrusel.
    - PLAN DE SOLUCIÓN:
        1. [ ] Modificar `ListCoordinator.forzarActualizacionEstadoAcciones()` para que opere sobre el ListContext ACTUAL (`model.getCurrentListContext()`).
        2. [ ] Asegurarse de que `GeneralController` llama a `getActiveCoordinator().forzarActualizacionEstadoAcciones()` después de cada navegación.

4.3. REFACTORIZACIÓN: Simplificar Delegación de Navegación en `GeneralController`
    - ESTADO: PENDIENTE
    - ANÁLISIS: Los métodos de navegación en GeneralController repiten la lógica if/else para delegar al VisorController o ProjectController.
    - PLAN DE SOLUCIÓN:
        1. [ ] Aplicar el patrón Strategy directamente en GeneralController.
        2. [ ] Inyectar las instancias de ListCoordinator y ProjectListCoordinator en GeneralController.
        3. [ ] Crear un método privado `getActiveCoordinator()` que devuelva el coordinador correcto según el WorkMode.
        4. [ ] Refactorizar los 6 métodos de navegación (`navegarSiguiente`, etc.) para que deleguen la llamada a `getActiveCoordinator()`.