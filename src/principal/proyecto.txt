------------------------------------------------------------------------------------------------------------------------------------

Implementacion LoogerFactory
----------------------------

private static final Logger logger = LoggerFactory.getLogger(AppInitializer.class); 
logger.info
logger.debug
logger.warn
logger.error
------------------------------------------------------------------------------------------------------------------------------------
La Solución: Cambiar el Nivel del Log
-------------------------------------
El nivel de log (level) funciona como un filtro. Si pones un nivel, solo se mostrarán los logs de ese nivel y los de niveles superiores. La jerarquía es:
TRACE < DEBUG < INFO < WARN < ERROR
Si pones level="DEBUG", se muestra todo (DEBUG, INFO, WARN, ERROR).
Si pones level="INFO", solo se muestra INFO, WARN, y ERROR.
Si pones level="WARN", solo se muestra WARN y ERROR.
Si pones level="ERROR", solo se muestra ERROR.
Si pones level="OFF", no se muestra absolutamente nada.
------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
FLATLAF

web para buscar componentes para cambiar el color: 
https://www.formdev.com/flatlaf/properties-files/
------------------------------------------------------------------------------------------------------------------------------------

1. - OBJETIVO DE ESTA SESIÓN:
[Aquí describes qué quieres lograr hoy. Ej: "Implementar la lógica para que el botón 'Exportar a PDF' genere un archivo con los datos de la tabla de clientes."]

2. - CONTEXTO GENERAL DE LA APLICACIÓN:

1. OBJETIVO DEL PROYECTO:

Aplicación de escritorio para visualizar, catalogar y gestionar una gran colección (~26,000+) de imágenes asociadas a modelos 3D. El objetivo principal es agilizar la búsqueda y organización de estos recursos.
2. ARQUITECTURA Y PRINCIPIOS DE DISEÑO:
Tecnología: Java, Swing (UI), Maven (Gestión de proyecto).
Layout Principal: CardLayout para cambiar entre los diferentes "modos" de la aplicación (Visualizador, Proyectos, Catalogador). La UI se compone de paneles modulares cuya visibilidad es configurable.
Barras de Herramientas: Múltiples JToolBar independientes que se muestran/ocultan según el contexto de la tarea actual.
Configuración y Futuro MegaConfig:
Actualmente, la configuración se gestiona a través de un archivo config.cfg.
Directriz de Diseño Clave: Todas las nuevas funcionalidades y refactorizaciones deben diseñarse de forma modular y flexible para facilitar su futura integración en una interfaz gráfica de configuración centralizada (MegaConfig). El código no debe tener valores "hard-coded" que luego sean difíciles de externalizar.
3. MÓDULOS PRINCIPALES:
A) Visualizador de Imágenes:
Vista Principal: Compuesta por tres paneles:
Lista de Nombres (JList): Muestra todos los nombres de archivo de la selección actual.
Barra de Miniaturas (JPanel con JScrollPane): Muestra un subconjunto de imágenes en miniatura para navegación rápida.
Visor Central: Muestra la imagen seleccionada a tamaño completo.
Lógica de Miniaturas (Crítico):
No se renderizan todas las miniaturas a la vez por rendimiento.
Se gestiona un "viewport" de miniaturas: al hacer scroll, se eliminan las miniaturas que salen de la vista y se añaden las nuevas.
Existe un sistema de caché de miniaturas para agilizar la carga.
El número de miniaturas visibles es dinámico y se adapta al ancho de la ventana.
Funcionalidades: Zoom (manual y predefinido), navegación por carpetas (con/sin subcarpetas), modos de visualización (Grid, Pantalla Completa, Carrusel), edición básica (rotar, espejo, recortar).
B) Gestor de Proyectos:
Permite marcar imágenes de interés.
Las imágenes marcadas se añaden a una lista temporal (ej. un archivo de texto).
Permite visualizar y gestionar estas listas como "proyectos" guardados.
C) Catalogador de Imágenes (Futuro/Grueso del proyecto):
Funcionalidad principal a largo plazo.
Utilizará una base de datos o metadatos para permitir búsquedas por etiquetas/tags (ej. "elfo", "skaven").
El objetivo es superar la limitación de la estructura de carpetas.
4. SINCRONIZACIÓN DE LISTAS:
Existe una lista de datos principal (el "modelo") que contiene la información de los archivos en disco.
Esta lista principal alimenta tanto a la JList de nombres como a la barra de miniaturas.
Un método de sincronización se encarga de que la selección en una lista se refleje correctamente en la otra y en el visor principal.


3. - DIRECTRICES INQUEBRANTABLES (Nuestras Reglas de Trabajo):
Regla 1 (CÓDIGO REAL): Trabaja siempre con el código real. Antes de darme un código basado en lo que supuestamente hace una clase/método, PIDE LA CLASE. No asumas ninguna implementación.
Regla 2 (COMENTARIOS): Añade siempre los comentarios de final de bloque // ---FIN de metodo [nombre]---  y // --- FIN de clase [nombre]---
Regla 3 (SIN RENOMBRAR): No se pueden cambiar los nombres de variables, métodos o clases que ya existen.
Regla 4 (NO REFACTORIZAR): No refactorices ni simplifiques métodos existentes sin consultarme primero. Céntrate únicamente en la tarea solicitada.
Regla 5 Formato de Entrega: Formato estándar de "busca y reemplaza" o "añade debajo". Es más claro y seguro para ambos.

4. - ESTRUCTURA DEL PROYECTO (dir /b /s):


--------------------------------------------------------------------------------------------------------------------------------------



	el github es: https://github.com/JavierTortosa/catalogador-imagenes-java.git
	
	este es un proyecto de un visualilzador/catalogador en java/swing (ahora maven/swing). 
	
	Idea general:
	Soy aprendiz de programador y me dedico bastante a menudo a hacer proyectos en 3d. 
	
	Este proyecto nace de la ncesidad de buscar entre cerca de 26000 imagenes.
	Cada una de estas imagenes corresponde a un archivo comprimido que es quien contiene los modelos a imprimir
	
	Los archivos estan separados por carpetas tematicas, las cuales pueden contener varios temas diferentes y de varias formas diferentes
	Para aclararnos, las carpetas pueden ser de cine, herramientes, escenografia, etc., y dentro de cada carpeta puede contener mas carpetas refinando el catalogo de archivos
	El problema es que puede ser por una tematica, cine, o puede ser por un diseñador, punga, o simplemente ser archivos stl con su imagen
	las carpetas tematicas no tienen demasiado problema, pero las de diseñadores pueden contener varios temas, ademas las imagenes pueden ser de 1 modelo o varios
	
	Los proyectos en 3d suelen ser tematicos por ej trofeos para toneo de blood bowl. para este proyecto necesitare buscar: bases, pedestales, una base superior y un modelo que represente el campeon por ej...
	Todo lo referente a trofeos esta en la carpeta trofeos, dentro hay otras carpetas de bases, pedestales, etc... 
	Luego tengo que ir buscando la figura que ira encima del toreo en funcion de la tematica del torneo, pongamos skaven. 
	El kit de la cuestion es buscar entre las 26000 imagenes, algun modelo que sea de la tematica que busco y que me sirva para el trofeo... 
	
	Lo que pretendo con este proyecto es poder agilizar dicha busqueda.


El programa:

El programa tiene 3 partes:
	Visualizador
	Gestor de proyectos
	catalogador de imagenes
	
Este es el orden en el que pretendo abordar el proyecto, ya que primero necesito un programa agil y rapido que me permita visualizar las imagenes rapidamente
En este punto tenemos varias herramientas:


-- El Visualizador --

	La interfaz:
		En la parte superior tiene un menu con la totalidad de opciones disponibles en el programa y una opcion de configuracion que en un futuro sera mucho mas completa
		A continuacion la barra de botones, que iran distribuidos en varias barras de herramientas y que segun donde estemos se mostraran unas herramientas u otras
			(no tiene ningun sentido que se visualicen los botones de movimiento en el carrousel si estamos editando una imagen) 
		En el centro de la aplicacion tenemos 3 partes:
			1. la lista de nombres de archivos (por si sabemos el nobmre de lo que buscamos y ordenacion de los archivos (nombre, carpeta, fecha...)
			2. la lista de miniaturas es la misma lista de nombres pero mostrando una pequeña lista de imagenes para navegacion rapida 
			3. vista de la imagen seleccionada. es la vista principal de la imagen seleccionada
		
	Formas de visualizar la interfaz 
		
		1. Navegador por carpetas, un selector de carpetas donde empezar la visualizacion de las imagenes
		2. Una opcion para que Se puede visualizar la carpeta actual o con las subcarpetas. muy util por la distribucion de las carpetas que tenemos
		3. Zoom. Hay 2 tipos:
			1. Zoom Manual que me permite acercar o alejar la imagen o moverla (muy practico en las imgaenes multiples)
			2. Tipos de zoom: son varias formas de ver las imagenes (sin restriccciones, ajutas al espacion maximo, ajustar al alto/ancho....)
				Este segundo tipo tiene una opcion para mantener o no las proporciones de la imagen
		2. Modos de visualizacion: 1 imagen, grid de imagenes, etc....
		3. Complemento al Modo de visualizacion: pantalla compeleta y carrousel
		4. Tanto el menu, como las diferentes listas, botones, etc se pueden hacer visibles o no... para ganar espacio de visualizacion
	
	Edicion
	
		1. la funciones basicas, rotar izq. y der., espejo horizonta y vertical
		2. Un modo de recortar (para las imagenes multiples) pero que sera capaz de de poder modificar la imagen actual 
			(tendra una serie de opciones para pegar el recorte en la imagen original, separar el recorte de la imagen original....)
		3. Varias formas de guardado tanto de la imagen nueva como la original como la modificacion.... 
		

-- Gestor de Proyectos --
					
	Se distribuye en varias fases: 
		1. una opcion de marcar las imagenes que nos interesa y añadir el archivo con su ruta en un txt temporal 
		2. Un visualizador de las imagenes marcadas (cambiando el foco entre las carpetas del disco o el contenido del txt)
		3. El archivo temporal se puede guardar con un nombre concreto y se pueden gestionar los diferentes proyectos
		
		
-- Catalogador de Imagenes --

	Es el grueso de la aplicacion, gestionando una base de datos o metadatos o algo similar en donde poder catalogar las imagenes, de tal forma que pueda buscar elfos, enanos, etc.
	Con la base de datos podremos implementar un gestor de proyectos que pueda ser mas refinado, el uso de tags, pero el trabajo de introducir los de 26000 imagenes puede ser duro.
	La complicacion mas grande de catalogar las imagenes es el tema de que la cantidad de archivos que tengo ahora y que va creciendo y por lo tanto se van refinando las carpetas
		(una carpeta que empezo siendo cine, ahora tiene star wars, señor de los anillos.... y dentro de star wars esta la carpeta de naves, personajes, droides... y asi hasta el infinito....

		 
--- MegaConfig - El Centro de Control del Usuario:

	Objetivo: Proporcionar una interfaz gráfica centralizada donde el usuario pueda ajustar finamente casi todos los aspectos del comportamiento y la apariencia de la aplicación, sin necesidad de editar manualmente el archivo config.cfg (aunque este seguirá siendo la base para la persistencia).

	Contenido Potencial (basado en lo que ya tienes y planeas):
		Visibilidad de Componentes de UI:
		Checkboxes para mostrar/ocultar la barra de menú, la barra de herramientas principal, la lista de archivos, la barra de miniaturas, las barras de información (superior e inferior) y los elementos individuales dentro de estas barras.
		Gestión de la visibilidad de botones individuales en la barra de herramientas (lo que ya tienes en el menú "Configuración -> Visualizar Botones" podría migrar o complementarse aquí).

	Configuración de Paneles y Layout:
		(Más avanzado) Opciones para cambiar la disposición de los paneles principales si decides ofrecer diferentes layouts.
		Configuración de la posición por defecto del divisor del JSplitPane.

	Comportamiento de la Aplicación:
		Opciones de "Carga de Imágenes" (subcarpetas, ordenación por defecto).
		Opciones de "Comportamiento General" (imagen de bienvenida, abrir última imagen, navegación circular, etc.).
		Configuración de la cantidad de miniaturas (antes/después), tamaño de miniaturas.
		Parámetros de zoom por defecto.

	Apariencia y Temas:
		Selector de temas (lo que ya tienes en el menú, pero podría tener una vista previa aquí).
		(Muy avanzado) Editor de temas o personalización de colores individuales si quisieras ir por ese camino, aunque gestionar un tema completo es más sencillo.
		Configuración de Teclado (Atajos):
		(Avanzado) Permitir al usuario personalizar algunos atajos de teclado.
		Configuración de la Base de Datos/Catalogador (Futuro):
		Ruta de la base de datos, opciones de indexación, etc.
		Botones de Acción: "Aplicar", "Cancelar", "Restaurar Defaults".
		
	--- Diseño de la UI
	
		La interfaz esta diseñada sobre un cardLayout que proporciona que cada modo tenga su interfaz como si fueran las paginas de un libro
		Sobre esta pagina estan establecidos unos paneles vacios para que en el futuro config podamos asignar el componente final al panel que queramos
		La barra de botones esta compuesta por varias toolbars independientes para poder ver la toolbar pertinente segun lo que estemos haciendo
		
	--- Diseño de las Listas
		
		Dado el gran volumen de imagnes, necesitamos formas de ver la mayor cantidad de imagnes en el menor tiempo posible y para eso tenemos las 2 listas, una de nombres y otra de miniaturas
		La lista de nombres contiene la lista completa de nombres que estamos viendo pero la lista de miniaturas solo esta mostrando una cantidad concreta en cada momento porque hacer 26000 miniaturas es una locura
		Como la lista de nombres y la de miniaturas funcionan de forma diferente, la lista de miniaturas se crea de forma manual, creando una miniatura y añadiendola a la barra de miniaturas
		Cuando nos movemos por esta lista de miniaturas, lo que estamos haciendo es eliminar la miniatura que ya no se ve y añadiendo una nueva (al principio o al final segun convenga)
		Para sincronizar las 2 listas, lo que tenemos es una lista principal que es la que realmente tiene la informacion del disco y la deriva a las 2 listas (miniaturas y nombres) y con un metodo lo sincronizamos todo
		Ademas para ayudarnos al desplazamiento de las miniaturas, usamos un scrollPane que nos da los medios para el desplazamiento, pero no contiene las miniaturas, sino el panel que creamos nosotros
		Tambien se creo un cache para que algunas de las miniaturas se fabriquen mientras estamos viendo las que estan en pantalla y asi agilizamos la barra de miniaturas
		En una version mas avanzada, se añadio que las miniaturas visibles fuera variable, de manera que se vean el maximo de miniaturas posible segun el ancho de la aplicacion

--------------------------------   		 
   		
Modos de trabajo

	Visualizador de imagenes
	Gestor de proyectos
	Catalogador de imagenes
	Carrousel
	Edicion
	
	   		 
--------------------------------


| Modo de Zoom                | BMP false (Modo Normal / "Confía en mí")                                                            | BMP true (Modo Seguro / "Ayúdame a verla")                                                    |
|-----------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| Ajustar a Pantalla          | Muestra la imagen entera, sin salirse. (BMP es irrelevante)                                         | Muestra la imagen entera, sin salirse. (BMP es irrelevante)                                   |
| Ajustar a Ancho             | La imagen se escala para ocupar el 100% del ancho del panel, manteniendo su proporción.             | Si al ajustar al ancho se sale por alto, se re-escala para que quepa entera (aplica Ajustar a Pantalla). |
|                             | Puede salirse por alto.                                                                             |
| Ajustar a Alto              | La imagen se escala para ocupar el 100% del alto del panel, manteniendo su proporción.              | Si al ajustar al alto se sale por ancho, se re-escala para que quepa entera (aplica Ajustar a Pantalla).  |
|                             | Puede salirse por ancho.                                                                            |
| Zoom 100% (Tamaño Real)     | La imagen se muestra a su tamaño real (1:1). Puede salirse.                                         | Si al 100% se sale de la pantalla, se re-escala para que quepa entera (aplica Ajustar a Pantalla).  |
| Zoom Fijo (Mantener Actual) | Usa el zoomFactor guardado. Ignora los límites del panel.                                           | Usa el zoomFactor guardado. Ignora los límites del panel.                                     |
| Zoom Específico             | Usa el % guardado. Ignora los límites del panel.                                                    | Usa el % guardado. Ignora los límites del panel.                                              |
| Rellenar                    | (ÚNICO CASO DE DEFORMACIÓN) Estira para ocupar el 100% del panel.                                   | Igual que en modo normal. (BMP es irrelevante)                                                |   		 
   		 
   		 
--------------------------------

pongamos un ejemplo de caso real....
pongamos que estoy buscando imagenes para un proyecto, y encuentro una imagen que es estrecha y alta. ese tipo de imagenes se que corresponde a un distribuidor en concreto, pulso el boton de mostrar solo carpeta de la imagen actual, y activo el modo de zoom ajustar a lo ancho.... pero la imagen es muy grande, asi que la reduzco para verla un poco mejor a pesar de que sobresale por arriba y por abajo. las imagenes de ese distribuidor estan en una misma carpeta, por lo que se que mostrando la carpeta actual voy a ver muchas imagenes con este mismo estilo y que es muy probable que el zoom que acabo de ajustar con la rueda del raton y el modo ajustar al ancho me serviran para las siguientes imagenes... entonces aplico el zoom fijo. a partir de ahora tolas las mage3nes que vea seran con ese zoom, pero de repente me encuentro una imagen que no corresponde con el formato, asi que paso a zoom especificado, manteniendo el % de las imagenes que he estado viendo hasta ahora y puede acercar o alejar la imagen sin cambios en el %z. en cuanto pase a la siguiente se volvera a aplicar el zoom que tenemoe en el popup....

--------------------------------

pongamos otro uso real para que veas como funcionan los modos como si todo funcionase y todo estuviera terminado....
me piden que haga 6 trofeos para un torneo de blood bowl. el torneo es la Parabellum Cup, en honor a un bar que empezo con esto de los torneos y su logo eran unos skaven jugando... por lo tanto el tema principal es Skavens...

vale. abrimos el programa y nos enfrentamos a 26000 imagenes. con la ayuda de la base de datos del modo Datos, tenemos las imagenes con unas etiquetas (TAGS)
vale. como el tema es skaven, aplicamos un filtro positivo en "SKAVEN", de las 26000 ya solo se nos muestran 5000....
ahora aplicamos otro filtro "BIG GUY" para que nos enseñe las ratas mas gordas y lustrosas para nuestros trofeos, ahora se muestran 2000. porque solo se muestran de las 26000 imagenes las que son skaven y big guy
vamos mirando imagen por imagen y vamos marcando las que nos pueden interesar.... total seleccionamos 20, por ej.
vamos al modo proyecto, y empezamos a mirar las imagenes que hemos seleccionado, y empezamos a ver algunas seleccionadas que no nos convencen, las marcamos para desechar (que sera otra lista que es previa al borrado de estas marcas)
necesitamos en total 6, pero de las 20 que hemos seleccionado solo nos han convencido 4. entonces volvemos al modo visualizador
ahora aplicamos un filtro negativo "BIG GUY" ahora no queremos que se muestren los big guys,
ahora nos vamos a la carpeta de "juegos de mese/bloodBowl" vemos que las imagenes de skaven ya las habiamos visto y no nos han convencido, pues aplicamos otro filtro negativo de "SKAVEN" ahora solo se muestran las imagenes de la carpeta "Juegos de mesa/blooBowl" que no son ni skaven ni big guy.... ves por donde voy
encontramos una imagen que se llama "motosierra ratuna" esta no estaba con los skaven ni con los big guy por eso no la habiamos visto y ahora si la vemos....
como esta encontramos unas cuantas mas.... vamos al modo proyecto donde aun conservamos las candidatas que nos han convencido y las que no y ademas tambien estan las nuevas imagenes.... en este mismo momento todas las imagenes que estoy viendo son del mismo tema, skaven, pero unas tienen el tag y otras no.... pues pulso mi opcion de añadir tag en bloque y todas las que yo quiera tendran el nuevo tag "SKAVEN"....
una vez que he conseguido mis 6 imagenes puedo pulsar el boton de "busqueda y rescate" para que el programa se pasee por las 26000 imagenes y copie el archivo de imagen con el archivo comprimido que la acompaña a la carpeta que se le indique para modificar los stl, preprar los archivos de impresion, etc.....

el modo proyecto, ademas de reviar las imagenes con mas detenimiento, ya no tengo 26000 para mirar, solo tengo 40.... por lo tanto el modo zoom y el paneo son mas cruciales que en el modo visualizador.
por otro lado, el modo proyecto es una muy buena herramienta que complementa el modo datos, porque mientras estoy gestionando el proyecto actual, puedo añadir un tag comun a las imagenes que tengo marcadas "Todas estas imagenes tienen el tag " SKAVEN", y no solo eso sino que luego ademas puedo seleccionar un grupo para decir "este grupo que tengo marcado tienen el tag "CON ESPADA" por decir algo... estas otras "CON ARCO" lo que sea.... tags que me ayuden a aplicar filtros en las imagnees para no tener que buscar entre las 26000 imagenes que se dicen pronto.... (la semana que viene seguramente llegare a las 27000) que eso es otro tema que habra que abordar en su momento....
me explico?

--------------------------------

te voy a pasar la clase de inicio... desde ahi parte todo, quiero que vayas recorriendo el flujo del programa y me vayas pidiendo las clases que vayas necesitando inspeccionar....

a la hora de trabajar:
-te lo voy a decir asi, NO QUIERO, REPITO, NO QUIERO QUE ASUMAS EL FUNCIONAMIENTO DE NINGUNA CLASE NI METODO, TE PROHIBO TOTAL Y TERMINANTEMENTE QUE ASUMAS QUE UNA CLASE HACE ALGO O QUE DEBERIA CONTENER UN METODO O CUALQUIER INTENTO DE ASUMIR QUE ALGO ESTA SIN COMPROBARLO PRIMERO.... esta es la unica y mayor premisa que quiero que cumplas a rajatabla....ok?
-quiero que seas lo mas exacto posible, prefiero una respuesta clara y correcta antes que una respuesta rapida.
-quiero que me des metodos o bloques de codigo completos. no me valen lineas sueltas. los metodos tienen suficientes comentarios como para que me digas sustituye el bloque tal o por lo menos quiero que me des la linea de antes y despues del bloque de codigo que me das para modificar
- me gustaria que añadieras al final de cada metodo y cada clase añadas un comentario de fin de clase o lo que sea...
-cuando estemos discutiendo un problema, estamos comprobando las diferentes partes a las que afecta ese problema y posibles soluciones.... se que tienes muchas ganas de ayudar y por culpa de esas ganas sueles precipitar soluciones que al final no son validas porque yo puedo refutar una suposicion tuya con lo que la solucion se invalida. asi que cuando estemos discutiendo no pasamos al codigo hasta que el problema no este claro y estemos los 2 en la misma pagina, ok?


problemas y soluciones
1. primero te explico el problema y no pasamos al siguiente punto hasta que estemos de acuerdo
2. propones que puede ser 
3. miramos como abordar el problema y no pasamos al siguiente punto hasta que estemos de acuerdo
4. empezamos a aplicar la solucion. clase a clase, metodo a metodo.... NO ME DES LOS CAMBIOS DE 20 CLASES DE GOLPE


creo que esto es todo mi temario imperativo y me gustaria que lo siguieras lo mas filemente posible

-----------------------------------

ICONOS

https://www.streamlinehq.com/icons/core-duo-color 								-> Normales
https://www.streamlinehq.com/icons/streamline-colors?icon=ico_cqBlbF5QkFCCCVKo	-> A Color

https://www.streamlinehq.com/icons/core-duo-color/interface-essential












======================================================================
librerias externas para implementas
======================================================================
TwelveMonkeys ImageIO: Soporte extendido para formatos de imagen: PSD, TIFF, BMP, etc.
FlatLaf: el estándar de oro para Look and Feels modernos en Swing
Thumbnailator: para crear miniaturas fácilmente.
Caffeine: Caché en memoria ultra rápida (mejor que HashMap + LRU manual).
SQLite-JDBC: Base de Datos
JDBI o jOOQ: Para Interactuar con la Base de Datos

Resumen y Prioridades
---------------------
Imprescindibles para el "Modo Datos":
SQLite-JDBC: Para tener una base de datos sin complicaciones.
JDBI: Para hablar con esa base de datos sin volverte loco.

Mejoras de Calidad de Vida (muy recomendadas):
Thumbnailator (que ya mencionaste): Para miniaturas de alta calidad.
Caffeine (que ya mencionaste): Para un sistema de caché de nivel profesional.
Lombok: Para reducir drásticamente el código repetitivo.

Para Funcionalidad Avanzada (opcional, pero potente):
metadata-extractor: Si quieres empezar a leer metadatos incrustados en las imágenes.





***********************************************************************************************************************************

HOJA DE RUTA PARA IMPLEMENTAR LOS MODOS DE VISUALIZACIÓN DEL VISOR

OBJETIVO PRINCIPAL: Ofrecer al usuario diversas formas de explorar y interactuar con las imágenes, optimizadas para diferentes flujos de trabajo (revisión rápida, comparación, detallado, organización).

*** CONCEPTOS CLAVE PARA LA ARQUITECTURA DE MODOS ***

1.  Modo de Aplicación (AppMode):
    *   Define el contexto de trabajo principal: VISUALIZADOR, PROYECTO, DATOS, EDICION, ETC.
    *   Afecta la visibilidad y comportamiento de acciones, paneles laterales y menús/toolbars activas.

2.  Modo de Visualización de Contenido (DisplayMode):
    *   Define cómo se presentan las imágenes en el área central de la aplicación: SINGLE_IMAGE, GRID, CAROUSEL, POLAROID.
    *   Cuando el DisplayMode cambia, la parte central de la VisorView (probablemente usando un CardLayout) cambia de panel.

3.  Configuraciones de Vista (ViewConfiguration):
    *   Son ajustes que se aplican sobre cualquier DisplayMode.
    *   Ejemplos: FULL_SCREEN, SHOW_SUBFOLDERS, THUMBNAIL_SIZE, PANNING_ACTIVE.
    *   Estos son toggles o sliders que modifican el aspecto o comportamiento, pero no cambian el tipo de contenido que se muestra en el centro.

La cuestión de si el modo grid es un modo de trabajo o de visualización:
El GRID es un Modo de Visualización de Contenido (DisplayMode). No es un "modo de trabajo" (AppMode) en sí mismo, pero es un excelente modo para realizar trabajo. Las acciones que hagas en el GRID (marcar, recortar, añadir tags) son las mismas acciones que harías en SINGLE_IMAGE, pero aplicadas a múltiples elementos o con un flujo de trabajo distinto.

---

### FASE 1: REFINAMIENTO DE NAVEGACIÓN Y UX FUNDAMENTALES
(Consolida y pule el DisplayMode.SINGLE_IMAGE y establece bases para otros modos)

1.  **Persistencia del Estado de Visualización:** YA IMPLEMENTADO
    *   **Objetivo:** Al cerrar la aplicación, guardar la ruta de la última imagen vista y la carpeta actual. Al iniciar, intentar cargarla.
    *   **Detalles:**
        *   `VisorController`: En el ShutdownHook, obtener `model.getSelectedImagePath()` y `model.getCurrentFolderPath()`.
        *   `ConfigService` (o tu `Config` clase): Métodos `saveLastImagePath(path)` y `loadLastImagePath()`.
        *   `AppInitializer`: Al inicio, después de cargar la configuración, si hay una `lastImagePath` válida, usar `controller.loadImage(lastImagePath)`.
    *   **[TODO - VISUALIZADOR] no se guarda la imagen con la que cerramos la aplicacion**
    *   **Impacto UX:** Mejora la comodidad, el usuario retoma donde lo dejó.

2.  **Salto de Carpeta (Folder Skipping):**
    *   **Objetivo:** Permitir al usuario saltar a la siguiente/anterior carpeta en la jerarquía actual (misma profundidad).
    *   **Detalles:**
        *   `VisorController`: Implementar `jumpToNextFolder()` y `jumpToPreviousFolder()`.
        *   `FileNavigationService` (nueva clase o en `VisorModel`): Un método para obtener una lista ordenada de todas las carpetas hermanas del directorio actual.
        *   Manejar límites: si no hay siguiente/anterior.
        *   UI: Añadir botones en la barra de herramientas o ítems de menú específicos.
    *   **[TODO - VISUALIZADOR] HACER SALTO DE CARPETA:** Cuando estamos viendo una carpeta que vemos que no nos cuadra, poder saltar todas las imagenes de esa carpeta.
    *   **Impacto UX:** Agiliza la navegación cuando una carpeta entera no es relevante.

3.  **Control de Paneo con Atajos de Teclado (Ctrl+Alt):** YA IMPLEMENTADO
    *   **Objetivo:** Activar/desactivar el modo de paneo manteniendo `Ctrl + Alt` pulsados, cambiando el cursor.
    *   **Detalles:**
        *   `VisorView` (el panel de imagen): Implementar `KeyListener` para `keyPressed` y `keyReleased`.
        *   `VisorController`: Un campo `isPanningHotkeyPressed` y un método `setCursorForPanning(boolean active)`.
        *   El `MouseMotionListener` para el paneo solo actuará si `isPanningHotkeyPressed` es `true`.
    *   **[TODO - VISUALIZADOR] CTRL + ALT DEBE ACTIVAR EL MODO PANEO Y DESACTIVARLO CUANDO SE DEJA DE PULSAR**
    *   **Impacto UX:** Control más intuitivo y rápido sobre el paneo.

4.  **Desactivación Visual de Carga Rápida (Debounced Image Loading):**
    *   **Objetivo:** Al pasar rápidamente las imágenes con la rueda del ratón, evitar cargar la imagen completa de cada una, mostrando un "placeholder" hasta que el usuario se detenga.
    *   **Detalles:**
        *   `VisorController`: `MouseWheelListener`. En lugar de cargar la imagen, reiniciar un `javax.swing.Timer`.
        *   Mientras el temporizador está activo, el `VisorView` puede mostrar un "placebo" visual (ej. el nombre del archivo de destino, un icono de carga, o mantener la imagen anterior).
        *   Cuando el temporizador se dispara (usuario dejó de mover la rueda), se ejecuta la carga de la imagen real en un `SwingWorker`.
    *   **[TODO - VISUALIZADOR] Pasar las imagenes rapido con la rueda del raton no debe mostrar las imagenes, solo un placebo que parezca que estan pasando imagenes pero en realidad no se ve nada**
    *   **Impacto UX:** Mejora drásticamente la fluidez al navegar, elimina la sensación de "congelamiento".

5.  **Ajuste Dinámico del Tamaño de Miniaturas:**
    *   **Objetivo:** Botones o un slider para agrandar/encoger el tamaño de las miniaturas en la barra lateral y que se ajusten al espacio disponible.
    *   **Detalles:**
        *   `ConfigService`: Guardar `miniaturaDefaultSize` (o similar).
        *   `VisorController`: Métodos `increaseThumbnailSize()`, `decreaseThumbnailSize()`.
        *   `VisorView` (panel de miniaturas): Al cambiar el tamaño, recalcular el número de miniaturas por fila/columna y cómo se distribuyen. `revalidate()` y `repaint()`.
        *   UI: Botones en la toolbar (ej. `ZoomInMiniaturasAction`, `ZoomOutMiniaturasAction`).
    *   **[TODO - VISUALIZADOR] añadir botones de agrandar o encoger las miniaturas y que se ajuste a la pantalla**
    *   **Impacto UX:** Permite al usuario optimizar el espacio de miniaturas según su preferencia.

6.  **Menú Contextual (Popup Menu):** YA IMPLEMENTADO
    *   **Objetivo:** Acceso rápido a acciones comunes.
    *   **Detalles:**
        *   Crear un `JPopupMenu` con `JMenuItem`s que reutilicen tus `Action`s existentes (`ToggleMarkImageAction`, `ShowInExplorerAction`).
        *   Añadir `MouseListener` a los componentes relevantes (`JPanel` de la imagen principal, listas de nombres/miniaturas).
        *   En `mouseReleased(MouseEvent e)` (o `mousePressed`): `if (e.isPopupTrigger()) { popupMenu.show(e.getComponent(), e.getX(), e.getY()); }`.
        *   **Ítems esenciales:**
            *   "Marcar/Desmarcar Imagen" (reutiliza `CMD_PROYECTO_TOGGLE_MARCA`).
            *   "Mostrar Ubicación en Explorador" (`java.awt.Desktop.getDesktop().open(new File(imagePath).getParentFile());`).
            *   "Activar/Desactivar Paneo" (un `JCheckBoxMenuItem` que refleje el estado de `isPanningActive`).
    *   **[TODO - VISUALIZADOR] añadir el popup menu:** -marcar imagen, mostrar ubicacion de imagen, modo paneo,
    *   **Impacto UX:** Mayor eficiencia y descubrimiento de funciones.

7.  **Vista de Árbol de Carpetas (Folder Tree):**
    *   **Objetivo:** Reemplazar o complementar la lista de nombres de archivos con un `JTree` que muestre la jerarquía de carpetas.
    *   **Detalles:**
        *   `VisorView`: Incorporar un `JTree` en el panel izquierdo (al lado o en lugar de la lista de nombres/miniaturas).
        *   `DirectoryTreeModel` (nueva clase): Un `TreeModel` personalizado que carga los nodos del árbol perezosamente (`lazy loading`) para evitar la lentitud al explorar directorios con miles de subcarpetas.
        *   `TreeSelectionListener`: Al seleccionar una carpeta en el árbol, el `VisorController` carga el contenido de esa carpeta.
    *   **[TODO - VISUALIZADOR] mostrar arbol de carpetas**
    *   **Impacto UX:** Navegación por el sistema de archivos mucho más visual e intuitiva.

---

### FASE 2: IMPLEMENTACIÓN DE NUEVOS `DisplayMode`S
(Aquí es donde se cambian los paneles en el área central de la aplicación).

1.  **`DisplayMode.GRID` (Vista de Cuadrícula):** YA IMPLEMENTADO
    *   **Motivación:** Ver muchos modelos a la vez, facilitar la comparación y la selección masiva.
    *   **Detalles:**
        *   **Cambio de Panel:** Cuando se activa este modo, el `VisorView` cambia su `CardLayout` para mostrar un `JScrollPane` que contiene un panel personalizado para la cuadrícula.
        *   **Renderizado Eficiente (CRÍTICO):** No crear un `JLabel` por cada imagen. Se recomienda:
            *   Un `JList` con un `ListCellRenderer` personalizado que dibuja una fila de miniaturas y maneja el `wrap` (más sencillo de implementar).
            *   O un `JPanel` personalizado con un `LayoutManager` que dibuja solo las miniaturas visibles (`virtualized scrolling`, más complejo pero más flexible).
        *   **Tamaño de Miniaturas del Grid:**
            *   Botones `CMD_GRID_ZOOM_IN`, `CMD_GRID_ZOOM_OUT` para ajustar el tamaño de las celdas de la cuadrícula (ej. de 2x2 a 16x16 o más). Esto afecta cuántas imágenes se ven. Guardar la preferencia en `ConfigService`.
        *   **Navegación:**
            *   `AvPag` / `RePag`: Operarán sobre la lista *actualmente visible* del `DisplayMode.GRID`, avanzando por el número de imágenes configurado.
            *   Teclas de flecha: Navegar entre las celdas de la cuadrícula.
        *   **Selección Múltiple:** Habilitar `ListSelectionModel.MULTIPLE_INTERVAL_SELECTION` para la lista subyacente que representa la cuadrícula. Permitirá Shift+Click y Ctrl+Click.
        *   **Marcado en Grupo:** El botón "Marcar" o el menú contextual operaría sobre *todas* las imágenes seleccionadas.
    *   **[TODO - PROYECTO] permitir la seleccion multiple en modo proyecto**
    *   **[TODO - PROYECTO] permitir seleccionar varios archivos con el raton + shift por ej. para enviarlos a descartes o a exportar**
    *   **Impacto UX:** Poder comparar y seleccionar masivamente reduce drásticamente el tiempo de exploración para kits de modelos.

2.  **`DisplayMode.CAROUSEL` (Carrusel/Filmstrip):** YA IMPLEMENTADO
    *   **Motivación:** Revisión rápida de nuevo material sin clasificar, ideal para una primera pasada y marcación inicial.
    *   **Detalles:**
        *   **Cambio de Panel:** Panel con la imagen principal grande y una tira horizontal de miniaturas abajo (o arriba).
        *   **Tira de Miniaturas:** Un `JScrollPane` horizontal que contiene un `JPanel` con un `FlowLayout` o personalizado para renderizar la tira. La carga de estas miniaturas también debe ser eficiente (cache y virtualización si la tira es muy larga).
        *   **Sincronización:** La miniatura central en la tira es la imagen principal. Al navegar la imagen principal, la tira se desplaza para mantener la miniatura centrada. Al hacer clic en una miniatura, la imagen principal cambia.
        *   **Flujo de Trabajo:** Muy natural para "escaneo y marcar". Puedes ver las imágenes adyacentes al mismo tiempo que la principal.
    *   **Impacto UX:** Muy eficiente para una revisión inicial y categorización rápida.

3.  **`DisplayMode.POLAROID` (Modo Polaroid):**
    *   **Motivación:** Una forma más estética y relajada de visualizar imágenes, no tan centrada en la funcionalidad de trabajo.
    *   **Detalles:**
        *   **Cambio de Panel:** Un panel que renderiza la imagen principal con un marco blanco y una ligera inclinación.
        *   **Implementación:** Dibujar un `Rectangle2D` para el marco y aplicar una transformación `AffineTransform` para la rotación ligera al dibujar la imagen.
        *   **Interacciones:** Podría tener las mismas interacciones básicas que `SINGLE_IMAGE` (navegación, zoom), pero quizás con menos botones visibles para mantener la "limpieza".
    *   **Impacto UX:** Ofrece un respiro visual y un modo de "disfrute" de la colección.

---

### FASE 3: CONFIGURACIONES DE VISTA Y MANTENIMIENTO DEL ESTADO
(Estas opciones se aplican a cualquier `DisplayMode` activo).

1.  **Modo Pantalla Completa (`ViewConfiguration.FULL_SCREEN`):** (no confundir con el pantalla completa de la aplicacion)
    *   **Objetivo:** Maximizar el espacio de visualización para cualquier `DisplayMode`.
    *   **Detalles:**
        *   `VisorView.toggleFullScreen()`: Ocultar/mostrar `JMenuBar`, `JToolBar`s, panel izquierdo (listas/árbol), barra de estado. `JFrame.setExtendedState(JFrame.MAXIMIZED_BOTH)` o `JFrame.getGraphicsConfiguration().getDevice().setFullScreenWindow(frame)`.
        *   `VisorController`: Maneja el `boolean isFullScreen` en `VisorModel`.
    *   **[TODO - VISUALIZADOR] modo pantalla completa:** Es una forma de configurar la pantalla más que un modo en sí mismo, y se puede combinar con el modo grid.
    *   **Impacto UX:** Experiencia inmersiva para cualquier tipo de visualización.

2.  **Visibilidad de Componentes de UI (`ViewConfiguration`s):**
    *   **Objetivo:** Dar control al usuario sobre qué elementos de la interfaz son visibles.
    *   **Detalles:**
        *   `ConfigService`: Guardar el estado de visibilidad de `menuBarVisible`, `toolbarVisible`, `leftPanelVisible`, `thumbnailBarVisible`, `statusBarVisible`.
        *   `VisorView`: Métodos para mostrar/ocultar estos componentes (`jMenuBar.setVisible()`, `jToolBar.setVisible()`, `jSplitPane.setDividerSize(0)` para ocultar un panel, etc.).
        *   UI: `JCheckBoxMenuItem`s en el menú "Vista" o en la `MegaConfig` (futuro).
    *   **Impacto UX:** Permite al usuario personalizar la interfaz para sus preferencias y el tamaño de su pantalla.

3.  **Ajuste del Comportamiento de Acciones según `AppMode` y `DisplayMode`:**
    *   **Objetivo:** Que los botones y menús se comporten de forma inteligente.
    *   **Detalles:**
        *   Cada `Action` (ej. "Marcar Imagen", "Explorar Carpeta") en su `actionPerformed()` debe consultar el `currentAppMode` y `currentDisplayMode` para decidir su lógica.
        *   **Ejemplo "Marcar Imagen":**
            *   Si `AppMode == VISUALIZADOR`: Marca/desmarca en el proyecto activo temporal.
            *   Si `AppMode == PROYECTO` (`DisplayMode` puede ser `SINGLE_IMAGE` o `GRID`): Mueve la imagen (o la selección) a "Descartes" o "Proyecto" según dónde esté actualmente.
        *   **[TODO - PROYECTO] hacer que el boton de marcar imagen en modo proyecto mueva la imagen a descartes o viceversa**
        *   **Ejemplo "Selector de Carpeta/Archivo":**
            *   Si `AppMode == VISUALIZADOR`: Abre `JFileChooser` para seleccionar un *directorio*.
            *   Si `AppMode == PROYECTO`: Abre `JFileChooser` para seleccionar un *archivo de proyecto* (`.prj`).
        *   **[TODO - PROYECTO] ajustar los botones que se tienen que ver o modificar el comportamiento entre visualizador y proyecto:**
            *   -Marcar Imagen: debe desmarcar la imagen en modo proyecto y por lo tanto eliminarla del proyecto o debe mandar la imagen a descartes
            *   -Selector de Carpeta: en modo proyecto se deberia usar para abrir un proyecto, no para iniciar la exploracion de imagenes como en el visualizador
        *   **[TODO - PROYECTO] ajustar opciones del menu para que se activen o desactiven las que son o no relevantes en modo proyecto**
        *   **Habilitar/Deshabilitar Acciones:** La visibilidad y `isEnabled()` de los botones y `JMenuItem`s deben actualizarse cada vez que `currentAppMode` o `currentDisplayMode` cambian.
    *   **Impacto UX:** Interfaz intuitiva y coherente, donde las acciones tienen sentido en el contexto actual.

---

### FASE 4: EDICIÓN Y MANEJO AVANZADO DE ARCHIVOS
(Esta fase es crucial para el tipo de imágenes que manejas).

1.  **Herramienta de Recorte (Cropping Tool):**
    *   **Objetivo:** Permitir al usuario seleccionar una o varias áreas rectangulares para recortar.
    *   **Detalles:**
        *   **UI de Selección:** Un `JPanel` transparente superpuesto a la imagen principal. `MouseListener` para dibujar un rectángulo de selección (clic, arrastrar, soltar). Permitir redimensionar el rectángulo.
        *   **Modo de Recorte:** Un botón en la toolbar (`CMD_EDITAR_RECORTAR`) que activa/desactiva este modo. Cuando está activo, la imagen principal no se panearía/zoomearía con el ratón, sino que se controlaría el rectángulo de selección.
        *   **Acciones de Recorte:**
            *   `CMD_RECORTAR_GUARDAR_COMO_NUEVA`: Guarda la selección como una nueva imagen.
            *   `CMD_RECORTAR_SOBREESCRIBIR_ORIGINAL`: Reemplaza la imagen original con el recorte (pedir confirmación).
            *   `CMD_RECORTAR_EXTRAER_MULTIPLES_SELECCIONES`: Permite definir múltiples rectángulos de recorte en la misma imagen. Se procesan y se guardan como archivos separados (ej. `nombre_original_001.png`). Esto debe hacerse en un `SwingWorker` con `JProgressBar`.
    *   **Impacto UX:** Herramienta fundamental para segmentar las imágenes de modelos múltiples, especialmente para tu "locura" de cortar.

2.  **Operaciones Básicas de Imagen (Rotación, Espejo):**
    *   **Objetivo:** Rotar 90º (izq/der), espejo horizontal/vertical.
    *   **Detalles:**
        *   `ImageProcessingService` (nueva clase): Métodos para aplicar transformaciones a un `BufferedImage`.
        *   `VisorController`: Métodos que llaman al servicio, actualizan el `model` y la `view`.
        *   UI: Botones en la toolbar (`CMD_ROTAR_IZQ`, `CMD_ROTAR_DER`, `CMD_ESPEJO_H`, `CMD_ESPEJO_V`).
    *   **Impacto UX:** Permite corregir la orientación de las imágenes.

3.  **Gestión del Guardado Post-Edición:**
    *   **Objetivo:** Opciones claras para guardar los cambios de edición.
    *   **Detalles:**
        *   Si la imagen está editada (`model.isImageModified = true`), mostrar un indicador visual (ej. asterisco en el título de la ventana).
        *   Al intentar cerrar la aplicación o cambiar de imagen/carpeta: preguntar al usuario si desea guardar los cambios, descartarlos o cancelar.
        *   Opciones de guardado: "Guardar" (sobrescribir), "Guardar como..." (crear una nueva copia), "Descartar cambios".
    *   **Impacto UX:** Previene la pérdida de trabajo.

4.  **Exportación de Proyectos con Mover vs. Copiar:**
    *   **Objetivo:** Controlar si los archivos de un proyecto se copian o se mueven al exportar.
    *   **Detalles:**
        *   En el diálogo/proceso de exportación del `ProjectSelectionManager`, añadir una opción para "Mover archivos originales" vs. "Copiar archivos originales".
        *   Lógica: `Files.move()` vs `Files.copy()`.
        *   **Actualización BD/Proyecto (CRÍTICO):** Si se "mueven", las rutas en el proyecto y, eventualmente, en la base de datos, ¡deberán actualizarse a la nueva ubicación!
    *   **[TODO - PROYECTO] exportar el proyecto copiando archivos de imagen y comprimidos a una carpeta de trabajo (con todo lo que ello conlleva por si no existe un archivo con el mismo nombre, poder asignar un archivo comprimido a una imgen, etc....)** (Ya lo tienes casi implementado, solo faltaría el botón de mover).
    *   **Impacto UX:** Mayor flexibilidad para organizar los archivos físicos de los proyectos.

5.  **Barras de Progreso para Operaciones Largas:**
    *   **Objetivo:** Informar al usuario sobre el progreso de tareas que toman tiempo (ej. escaneo inicial de subcarpetas, carga de archivos asociados, exportación/movimiento masivo).
    *   **Detalles:**
        *   Utilizar `SwingWorker` y `JProgressBar` (`JDialog` modal).
    *   **[TODO - PROYECTO] cuando busca los archivos asociados deberia aparecer un progressbar indicando que esta buscando los archivos asociados....**
    *   **Impacto UX:** La aplicación se siente más profesional y responsiva.

---

### *** TODOS RESTANTES ESPECÍFICOS DEL MODO PROYECTO (Fuera de esta Hoja de Ruta del Visualizador) ***

Estos son puntos clave que ya mencionaste y que son más específicos de la gestión de proyectos que de la visualización en sí, por lo que serán abordados en la hoja de ruta del Modo Proyecto.

*   **[TODO - PROYECTO] hacer que el salto de pagina avance o retroceda los items que se estipulan en el config, ahora lo hace pero de la lista general, no en la lista especifica, si movemos items a descartes pasa del item 0 al 10 pero si en medio no hay items porque estan en descartes va al item 10 igual**
    *   (Esto requiere que la paginación opere sobre la lista *filtrada/activa* del proyecto, descartes, etc.)
*   **[TODO - PROYECTO] implementar la barra de multiproyectos**

---






-------------------------------------------------------------------------
--- HOJA DE RUTA PARA IMPLEMENTAR EL MODO DATOS ---
-------------------------------------------------------------------------

Fase 1: Diseño y Arquitectura de la Base de Datos

1. Diseñar la estructura de la BD:
   - Tabla imagenes:
     - id (PK, autoincrement)
     - ruta (String, path completo en disco)
     - nombre_archivo (String)
     - fecha_modificacion
     - carpeta (posiblemente desglosada o sólo la carpeta padre)
     - Otros metadatos útiles (tamaño, dimensiones, etc.)
   - Tabla tags:
     - id (PK)
     - nombre_tag (único)
   - Tabla intermedia imagen_tags (muchos a muchos):
     - imagen_id (FK a imagenes)
     - tag_id (FK a tags)
   - Tabla proyectos (opcional, para vincular proyectos con imágenes):
     - id
     - nombre_proyecto
     - Otros metadatos del proyecto
   - Tabla intermedia proyecto_imagen (muchos a muchos):
     - proyecto_id
     - imagen_id

2. Elegir la tecnología para la BD:
   - Recomendación: SQLite (ligera, embebida, sin servidor, perfecta para escritorio).
   - Usar JDBC para conexión.

3. Crear capa de acceso a datos (DAO):
   - Clases Java que abstraen el acceso a la BD para:
     - Añadir/modificar/eliminar imágenes
     - Añadir/modificar/eliminar tags
     - Relacionar imágenes y tags
     - Consultas (búsquedas, filtros)

Fase 2: Población inicial y sincronización

1. Escaneo inicial del directorio raíz:
   - Leer todas las imágenes en disco (recursivo).
   - Insertar sus rutas y metadatos en la tabla imagenes si no existen.
   - Crear tags automáticos basados en la estructura de carpetas.
     - Ejemplo: si una imagen está en /figuras/cine/star wars/droides/, asignar tags: figuras, cine, star wars, droides.
   - Esto puede hacerse con un proceso batch o incremental.

2. Sincronización periódica:
   - Controlar si imágenes han sido añadidas, eliminadas o movidas.
   - Actualizar base de datos en consecuencia.
   - Marcar imágenes huérfanas (en BD pero no en disco) para revisión.

Fase 3: Sistema de Tags

1. Crear UI para gestión de tags:
   - Añadir tags individuales a una imagen.
   - Añadir tags masivos a selección de imágenes (desde modo Proyecto o desde modo Datos).
   - Eliminar tags de imágenes.

2. Tags en modo Proyecto:
   - Al seleccionar imágenes en proyecto, poder asignar un tag común a todas.
   - Esto ayudará a alimentar la BD sin procesar imagen por imagen.

3. Tags en modo Datos:
   - Sistema para filtrar imágenes por tags positivos y negativos.
   - Buscar imágenes sin tags (huérfanas).
   - Ordenar imágenes por tags (por ejemplo: mostrar primero imágenes con determinado tag).

4. Persistencia y consistencia:
   - Asegurar que cada cambio en tags se refleje inmediatamente en la BD.
   - Actualizar la UI en tiempo real.

Fase 4: Filtros y Búsquedas Avanzadas en Visualizador

1. Integración de filtros en visualizador:
   - Filtros positivos: solo imágenes con estos tags.
   - Filtros negativos: excluir imágenes con estos tags.
   - Combinación de filtros (AND, OR, NOT).

2. Mostrar resultados filtrados en lista de nombres y miniaturas.

3. Opciones de ordenación:
   - Por nombre, fecha, carpeta, o tags.

4. Visualización en modo datos:
   - Permitir previsualizar imágenes dentro del modo Datos (lista/miniaturas + imagen seleccionada).

Fase 5: Control y Gestión de Imágenes Huérfanas y Sin Tags

1. Detectar imágenes en BD que no existen en disco (huérfanas).
   - Mostrar alertas o listado para limpiar BD.

2. Detectar imágenes sin tags.
   - Mostrar para facilitar etiquetado.

3. Opciones para etiquetar rápido o eliminar registros huérfanos.

Fase 6: Movimiento y Reubicación de Archivos desde Modo Proyecto

1. UI para seleccionar imágenes y destino de carpeta:
   - Confirmación de movimiento masivo.
   - Posibilidad de crear subcarpetas destino automáticamente.

2. Actualizar en BD las rutas de las imágenes movidas.

3. Actualizar tags si la carpeta destino implica nuevos tags automáticos.

4. Mantener histórico (log) de movimientos.

Fase 7: Validación y Control de Acceso a Datos

1. No se requiere autentificación, pero sí:
   - Verificación de integridad en cada acceso a BD.
   - Manejo de excepciones si los datos no existen o están corruptos.

2. Sincronización con disco:
   - Validar que las rutas en BD coincidan con disco.

3. Opciones de reparación automática o manual.

Extras Recomendados

- Cache de consultas frecuentes para acelerar filtros y búsquedas.
- Indexación de tags en BD para consultas rápidas.
- Exportación/Importación de proyectos con sus tags.
- Interfaz para asignar múltiples tags a la vez con autocompletado.
- Vista previa rápida al pasar el cursor sobre tags o imágenes.

Resumen

| Paso | Qué Implementar | Impacto en otros modos |
|-------|-----------------|-----------------------|
| 1 | BD estructurada y DAO | Base de datos central |
| 2 | Escaneo inicial y sincronización | Población de datos, base para búsquedas |
| 3 | Gestión y asignación de tags | En proyecto y datos, alimenta filtros |
| 4 | Filtros en visualizador y modo datos | Navegación rápida y específica |
| 5 | Control huérfanos y sin tags | Limpieza y etiquetado |
| 6 | Movimiento archivos desde proyecto | Reubicación, actualización BD |
| 7 | Control acceso y validación | Robustez del sistema |


-------------------------------------------------------------------------
--- FIN DE LA HOJA DE RUTA PARA IMPLEMENTAR EL MODO DATOS ---
-------------------------------------------------------------------------



=========================================================
 HOJA DE RUTA - VISOR DE IMÁGENES V2
=========================================================

FASE 1: REFINAMIENTO DE NAVEGACIÓN Y UX FUNDAMENTALES
---------------------------------------------------------

[v] 1.1: Integrar Zoom Inteligente (SMART_FIT) en la UI
    - [v] Crear la Action correspondiente en ActionFactory (AplicarModoZoomAction para SMART_FIT).
    - [v] Añadir la constante CMD_ZOOM_TIPO_SMART_FIT en AppActionCommands.
    - [v] Añadir el botón a la barra de herramientas "zoom" en UIDefinitionService.
    - [v] Añadir el JRadioButtonMenuItem al menú "Zoom".
    - [v] Confirmar que es el modo por defecto al iniciar la aplicación.

[v] 1.2: Paneo Rápido con Atajos de Teclado (Ctrl + Alt)
    - [v] Modificar GeneralController (KeyEventDispatcher) para detectar la pulsación y liberación de Ctrl+Alt.
    - [v] Añadir un flag (ej. `isPanHotkeyPressed`) en GeneralController.
    - [v] Modificar los listeners de `mouseDragged` para que activen el paneo si `isZoomHabilitado()` O `isPanHotkeyPressed` es true.
    - [v] Implementar la lógica para cambiar el cursor del ratón a una mano (Cursor.HAND_CURSOR) cuando las teclas están presionadas.

[ ] 1.3: Navegación Fluida con Carga Retardada (Debounced Loading)
    - [ ] En GeneralController (o donde se gestione la rueda del ratón), en lugar de llamar a `navegarSiguiente/Anterior` directamente, reiniciar un `javax.swing.Timer`.
    - [ ] Cuando el Timer se dispare (el usuario ha parado), ejecutar la lógica de cambio de imagen.
    - [ ] (Opcional) Mostrar un "placeholder" o simplemente no hacer nada visualmente mientras la rueda se mueve rápido.

[v] 1.4: Persistencia de la Última Imagen Vista
    - [v] En `VisorController.guardarConfiguracionActual()`, asegurarse de guardar `model.getSelectedImageKey()` en una clave de config (ej. `inicio.imagen`).
    - [v] En `AppInitializer`, al cargar la configuración, leer esta clave.
    - [v] Pasar esta clave a `visorController.cargarListaImagenes()` para que la seleccione al iniciar.

[ ] 1.5: Salto Rápido entre Carpetas (Folder Skipping)
    - [ ] Crear nuevas Actions en ActionFactory (ej. `NextFolderAction`, `PreviousFolderAction`).
    - [ ] Implementar la lógica (posiblemente en una nueva clase `FolderNavigationService`) que, dada la carpeta actual, encuentre la siguiente/anterior carpeta hermana.
    - [ ] El `VisorController` llamará a este servicio y luego a `cargarListaImagenes` con la nueva ruta.
    - [ ] Añadir botones y atajos para estas nuevas acciones.

[ ] 1.6: Ajuste Dinámico del Tamaño de Miniaturas
    - [ ] Crear Actions `IncreaseThumbnailSizeAction` y `DecreaseThumbnailSizeAction`.
    - [ ] Estas acciones modificarán valores en `ConfigurationManager` (ej. `miniaturas.tamano.normal.ancho`).
    - [ ] El `ListCoordinator` o `VisorController`, al detectar este cambio, debe forzar una recreación del `MiniaturaListCellRenderer` y un `revalidate/repaint` de la `JList` de miniaturas.

[ ] 1.7: Vista de Árbol de Carpetas (Folder Tree)
    - [ ] Crear una vista alternativa para el panel izquierdo que contenga un `JTree`.
    - [ ] Implementar un `TreeModel` personalizado que cargue los directorios de forma perezosa (lazy loading) para un buen rendimiento.
    - [ ] Añadir un `TreeSelectionListener` que actualice la carpeta raíz del `VisorModel` y recargue las imágenes cuando se selecciona una nueva carpeta.
    - [ ] Añadir una Action para cambiar entre la vista de lista de archivos y la vista de árbol.


FASE 2: IMPLEMENTACIÓN DE NUEVOS MODOS DE VISUALIZACIÓN (DisplayMode)
-------------------------------------------------------------------------

[ ] 2.1: Implementar DisplayMode.GRID (Vista de Cuadrícula)
    - [v] Crear la clase `GridDisplayPanel.java` (usando `JList` con `HORIZONTAL_WRAP` y `JScrollPane`).
    - [v] Crear `GridCellRenderer.java`, un `ListCellRenderer` que dibuje una miniatura con su nombre debajo. Debe usar la lógica SMART_FIT para escalar la miniatura dentro de la celda.
    - [v] Crear nuevas Actions `GridZoomInAction` y `GridZoomOutAction` que llamen a métodos en `GridDisplayPanel` para cambiar el número de columnas/tamaño de celda.
    - [ ] Añadir una barra de herramientas inferior al `GridDisplayPanel` para estos nuevos controles.
    - [ ] Habilitar la selección múltiple en la `JList` interna.
    - [ ] Adaptar las acciones (ej. "Marcar") para que operen sobre todos los elementos seleccionados en el grid.

[ ] 2.2: Implementar DisplayMode.CAROUSEL (Carrusel/Filmstrip)
    - [v] Crear la clase `CarouselDisplayPanel.java`.
    - [v] El panel tendrá un `ImageDisplayPanel` grande en el centro y un `JScrollPane` horizontal (la tira) en la parte inferior.
    - [ ] La tira de miniaturas puede ser una `JList` en modo `HORIZONTAL_WRAP` con una sola fila de alto (`setVisibleRowCount(1)`).
    - [v] Implementar la lógica de sincronización: al cambiar la imagen principal, la `JList` de la tira hace `ensureIndexIsVisible`. Al hacer clic en la tira, se cambia la imagen principal.

[ ] 2.3: Implementar DisplayMode.POLAROID
    - [ ] Crear la clase `PolaroidDisplayPanel.java`.
    - [ ] Sobrescribir `paintComponent` para dibujar un rectángulo blanco de fondo.
    - [ ] Usar `AffineTransform` para aplicar una rotación ligera (`g2d.rotate(...)`) antes de dibujar la imagen.


FASE 3: AJUSTES DE COMPORTAMIENTO POR CONTEXTO (WorkMode)
----------------------------------------------------------------

[ ] 3.1: Habilitar/Deshabilitar Actions según el Modo
    - [ ] Modificar el método `updateEnabledState` de todas las `ContextSensitiveAction` para que consideren el `WorkMode` y `DisplayMode` actuales.
    - [ ] Por ejemplo, las acciones de paneo y zoom de imagen única deben deshabilitarse cuando el `DisplayMode` es `GRID`.
    - [ ] La acción "Marcar Imagen" debe cambiar su lógica: en modo `PROYECTO`, mueve a descartes/selección; en modo `VISUALIZADOR`, añade al proyecto temporal.

[ ] 3.2: Adaptar el Selector de Archivo/Carpeta
    - [ ] La acción `OpenFileAction` debe comprobar el `WorkMode` actual.
    - [ ] Si es `VISUALIZADOR`, abre un `JFileChooser` para seleccionar directorios.
    - [ ] Si es `PROYECTO`, abre un `JFileChooser` para seleccionar archivos de proyecto (ej. `.visprj`).
    
    
    
    
/*
**********************************************************************************************************************
*********************************************************************************** MEGACOMENTARIO PARAA CARGA Y ORDEN
**********************************************************************************************************************

¡Excelente decisión! La disciplina ahora te ahorrará dolores de cabeza después.

Aquí tienes un prompt detallado que resume lo que hemos discutido sobre la refactorización de la funcionalidad de "Carga y Orden", moviendo la configuración por defecto al menú "Configuración" y añadiendo una barra de herramientas para la ordenación temporal. Puedes usar esto como tu hoja de ruta cuando retomes esta parte.

---

**Prompt para la Refactorización de la Funcionalidad de "Carga y Orden"**

**Objetivo General:**
Separar la configuración de la ordenación *por defecto* (persistente) de la capacidad de aplicar una ordenación *temporal* a la vista actual. Mejorar la usabilidad proporcionando acceso rápido a la ordenación temporal mediante una nueva sección en la barra de herramientas y simplificando los menús.

**Fases y Tareas Detalladas:**

**FASE 1: Definición de Comandos y Estados en el Modelo**

1.  **`controlador.commands.AppActionCommands.java`:**
    *   **Definir/Verificar Comandos para Ordenación por Defecto (Configuración):**
        *   `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_NOMBRE` (ej: "cmd.config.orden.default.crit.nombre")
        *   `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_TAMANO`
        *   `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_FECHA`
        *   `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_EXTENSION`
        *   `CMD_CONFIG_ORDEN_DEFAULT_DIRECCION_ASC`
        *   `CMD_CONFIG_ORDEN_DEFAULT_DIRECCION_DESC`
        *   `CMD_CONFIG_ORDEN_DEFAULT_DIRECCION_NINGUNO` (si se mantiene "Sin Ordenar" como opción default)
    *   **Definir/Verificar Comandos para Ordenación Temporal (Toolbar/Acción Rápida):**
        *   `CMD_ORDEN_TEMP_SET_CRITERIO_NOMBRE` (ej: "cmd.orden.temp.crit.nombre")
        *   `CMD_ORDEN_TEMP_SET_CRITERIO_TAMANO`
        *   `CMD_ORDEN_TEMP_SET_CRITERIO_FECHA`
        *   `CMD_ORDEN_TEMP_SET_CRITERIO_EXTENSION`
        *   `CMD_ORDEN_TEMP_TOGGLE_DIRECCION` (para un botón que cicle Asc/Desc) O:
        *   `CMD_ORDEN_TEMP_SET_DIRECCION_ASC`
        *   `CMD_ORDEN_TEMP_SET_DIRECCION_DESC`
        *   `CMD_ORDEN_TEMP_SET_DIRECCION_NINGUNO` (si se mantiene "Sin Ordenar" como opción temporal)

2.  **`modelo.VisorModel.java`:**
    *   **Añadir Enums para Criterio y Dirección (si no existen):**
        ```java
        public enum CriterioOrdenacion { NOMBRE, TAMANO, FECHA, EXTENSION, NINGUNO }
        public enum DireccionOrdenacion { ASCENDENTE, DESCENDENTE, NINGUNO } // 'NINGUNO' para dirección puede ser implícito si el criterio es NINGUNO
        ```
    *   **Campos para Configuración de Ordenación por Defecto:**
        *   `private CriterioOrdenacion criterioOrdenacionDefault = CriterioOrdenacion.NOMBRE;`
        *   `private DireccionOrdenacion direccionOrdenacionDefault = DireccionOrdenacion.ASCENDENTE;`
        *   Getters y Setters (los setters serán llamados por las Actions de Configuración).
        *   Estos campos se inicializarán desde `ConfigurationManager` al arrancar la aplicación.
    *   **Campos para Ordenación Temporal de la Vista Actual:**
        *   `private CriterioOrdenacion criterioOrdenacionTemporal;`
        *   `private DireccionOrdenacion direccionOrdenacionTemporal;`
        *   Getters y Setters (los setters serán llamados por las Actions de la Toolbar).
        *   Al cargar una nueva carpeta, estos campos temporales se resetean a los valores `...Default` o a un estado "sin ordenación temporal activa".

**FASE 2: Definición de la Interfaz de Usuario (`UIDefinitionService.java`)**

1.  **Menú "Imagen":**
    *   **Eliminar** el submenú "Carga y Orden" y todos sus ítems.

2.  **Menú "Configuración" -> Submenú "Carga y Ordenación" (o similar):**
    *   Este submenú ahora contendrá las opciones para establecer los **defaults persistentes**.
    *   **Sub-Submenú "Criterio de Ordenación Predeterminado":**
        *   Grupo de `JRadioButtonMenuItem`s vinculados a `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_...`.
        *   Textos: "Nombre", "Tamaño", "Fecha", "Extensión".
    *   **Sub-Submenú "Dirección de Ordenación Predeterminada":**
        *   Grupo de `JRadioButtonMenuItem`s vinculados a `CMD_CONFIG_ORDEN_DEFAULT_DIRECCION_...`.
        *   Textos: "Ascendente", "Descendente", "Sin Ordenar" (opcional).

3.  **Barra de Herramientas (Nueva Sección "Ordenación"):**
    *   **Botón/Control para Criterio de Ordenación Temporal:**
        *   **Opción A (Botón con `JPopupMenu`):**
            *   `ToolbarButtonDefinition` para un `JButton` principal (ej. `CMD_ORDEN_TEMP_MOSTRAR_CRITERIOS`, texto "Ordenar Por:", icono genérico de orden).
            *   El `JPopupMenu` se construiría dinámicamente en `ToolbarBuilder` o se asociaría en `VisorController`, conteniendo ítems para "Nombre", "Tamaño", etc., cada uno vinculado a su `CMD_ORDEN_TEMP_SET_CRITERIO_...`.
        *   **Opción B (`JComboBox`):**
            *   No se define directamente como `ToolbarButtonDefinition`. `ToolbarBuilder` crearía un `JComboBox` y lo poblaría. Se necesitaría un `ActionListener` o `ItemListener` para él.
    *   **Botón/Control para Dirección de Ordenación Temporal:**
        *   **Opción A (Botón Cíclico `JButton`):**
            *   `ToolbarButtonDefinition` para un `JButton` (ej. `CMD_ORDEN_TEMP_TOGGLE_DIRECCION`). Icono y texto cambiarán según el estado (A-Z, Z-A, ---).
        *   **Opción B (Grupo de `JToggleButton`):**
            *   Dos o tres `ToolbarButtonDefinition` para `JToggleButton`s (ej. `CMD_ORDEN_TEMP_SET_DIRECCION_ASC`, `CMD_ORDEN_TEMP_SET_DIRECCION_DESC`), agrupados visualmente y en un `ButtonGroup`.

**FASE 3: Implementación de Actions (`ActionFactory.java`)**

1.  **Actions para Configuración de Orden por Defecto:**
    *   Clase: `SetOrdenDefaultAction` (o nombres más específicos como `SetCriterioOrdenDefaultAction`, `SetDireccionOrdenDefaultAction`).
    *   Constructor: Recibe `ConfigurationManager`, el criterio/dirección que representa, y la clave de config a modificar.
    *   `actionPerformed()`: Llama a `configuration.setString("clave.default.criterio", "valor_criterio")` y `configuration.setString("clave.default.direccion", "valor_direccion")`. Actualiza el estado `.seleccionado` de los radios en su grupo.
    *   Estas `Action`s se asignarán a los `JRadioButtonMenuItem` del menú "Configuración".

2.  **Actions para Ordenación Temporal (Toolbar):**
    *   **Para Criterio:**
        *   Si es `JPopupMenu`: Cada `JMenuItem` del popup necesita una `Action` (ej. `AplicarCriterioOrdenTemporalAction`) que tome el criterio como parámetro.
        *   `actionPerformed()`: Llama a `model.setCriterioOrdenacionTemporal(nuevoCriterio)`, actualiza el texto/icono del botón principal de la toolbar, y dispara la reordenación (`controller.solicitarReordenacionVistaActual()`).
    *   **Para Dirección:**
        *   Si es botón cíclico: Una `Action` (`ToggleDireccionOrdenTemporalAction`).
            *   `actionPerformed()`: Ciclac `model.getDireccionOrdenacionTemporal()`, actualiza el icono/texto del botón, y dispara la reordenación.
        *   Si son `JToggleButton`s: `Action`s individuales (`SetDireccionAscTemporalAction`, `SetDireccionDescTemporalAction`).
            *   `actionPerformed()`: Establece `model.setDireccionOrdenacionTemporal(...)`, actualiza `Action.SELECTED_KEY`, y dispara reordenación.

**FASE 4: Lógica en Controladores y Servicios**

1.  **`VisorController.java`:**
    *   **`cargarListaImagenes(String claveImagenAMantener)`:**
        *   Al inicio, obtener `criterioActivo` y `direccionActiva`:
            *   Si `model.getCriterioOrdenacionTemporal()` no es "ninguno" o `null`, usar los valores temporales.
            *   Si no, usar `model.getCriterioOrdenacionDefault()` y `model.getDireccionOrdenacionDefault()`.
        *   Usar `criterioActivo` y `direccionActiva` para ordenar `clavesOrdenadas` (o el `mapaResultado`) ANTES de crear el `DefaultListModel` para `listaNombres`. Esto requerirá un `Comparator` personalizado.
    *   **`solicitarReordenacionVistaActual()` (Nuevo método):**
        *   Llamado por las `Action`s de ordenación temporal.
        *   Obtiene la `claveImagenAMantener` del `model.getSelectedImageKey()`.
        *   Llama a `cargarListaImagenes(claveImagenAMantener)` para forzar una recarga y reordenación con los nuevos criterios temporales.
        *   Actualiza la UI de la toolbar de ordenación para reflejar el estado actual.

2.  **`ConfigurationManager.java`:**
    *   **`DEFAULT_CONFIG`:** Añadir las nuevas claves para la ordenación por defecto:
        *   `comportamiento.orden.default.criterio = NOMBRE` (o el que prefieras)
        *   `comportamiento.orden.default.direccion = ASCENDENTE`
        *   Claves `.seleccionado` para los `JRadioButtonMenuItem` del menú "Configuración" que controlan estos defaults.
    *   **`createDefaultGroupCommentsMap()`:** Añadir comentarios para estas nuevas secciones/claves.
    *   **`guardarConfiguracionActual()` en `VisorController`:** Debe asegurar que los valores de `model.getCriterioOrdenacionDefault()` y `model.getDireccionOrdenacionDefault()` se escriban en `estadoFinalAGuardar` con las claves correctas (esto podría hacerse obteniéndolos de las `Action`s de configuración si estas actualizan `this.configuration`, o directamente del modelo si las `Action`s solo actualizan el modelo y el `config.cfg`).

3.  **`MenuBarBuilder.java` y `ToolbarBuilder.java`:**
    *   Adaptarlos para construir los nuevos ítems de menú y los componentes de la toolbar de ordenación, asignando las `Action`s correctas.
    *   `ToolbarBuilder` podría necesitar lógica especial para el botón de criterio con `JPopupMenu` o para los `JToggleButton` agrupados.

4.  **`AppInitializer.java`:**
    *   En `aplicarConfiguracionAlModelo()`: Leer `comportamiento.orden.default.criterio` y `comportamiento.orden.default.direccion` de `configuration` y establecerlos en `model.setCriterioOrdenacionDefault()` y `model.setDireccionOrdenacionDefault()`.
    *   En `aplicarConfigAlaVistaInternal()`: Asegurar que los `JRadioButtonMenuItem` del menú "Configuración" para la ordenación por defecto reflejen el estado cargado.

**FASE 5: Sincronización Visual**

*   Cuando se cambia un criterio o dirección de ordenación temporal (desde la toolbar), los botones de la toolbar deben actualizar su apariencia.
*   Cuando se cambia un criterio o dirección de ordenación por defecto (desde el menú Configuración), los `JRadioButtonMenuItem` de ese menú deben actualizar su estado seleccionado. (Las `Action`s deberían manejar esto con `Action.SELECTED_KEY` y `ButtonGroup`).

---

Este prompt es bastante exhaustivo, pero cubre los cambios necesarios en las diferentes capas de tu aplicación para implementar la funcionalidad de ordenación de forma clara y separada para la configuración persistente y la manipulación temporal.

Cuando estés listo, puedes ir abordando cada fase. ¡No dudes en preguntar si algo no está claro o si necesitas ayuda con una parte específica!

  
*/    



HOJA DE RUTA: IMPLEMENTACIÓN DEL MODO DE VISUALIZACIÓN GRID

Versión: 1.0
Fecha: 23/05/2024
Proyecto: Visor/Catalogador de Imágenes

======================================================================
== OBJETIVO GENERAL
======================================================================
Implementar un modo de visualización "Grid" (cuadrícula) completamente funcional y reutilizable, que permita al usuario ver múltiples imágenes a la vez, realizar selecciones múltiples y sirva como base para futuras operaciones por lotes. La implementación debe integrarse de forma nativa en la arquitectura existente (MVC, Managers, ComponentRegistry, Model-driven UI).

======================================================================
== FASE 1: CONSTRUCCIÓN DE LOS COMPONENTES DE LA VISTA (UI)
======================================================================

1.1. Creación del Panel de Visualización del Grid:
    - Nombre del archivo: `vista/panels/GridDisplayPanel.java`
    - Heredará de: `JPanel` con `BorderLayout`.
    - Componente principal interno: `JList<String>` configurado para actuar como un grid (`setLayoutOrientation(JList.HORIZONTAL_WRAP)` y `setVisibleRowCount(-1)`).
    - El `JList` estará contenido en un `JScrollPane`.
    - Responsabilidades:
        - Mostrar una cuadrícula de celdas.
        - Ser "tonto" en cuanto a datos: recibe una lista de claves de imagen y la muestra.
        - Exponer su `JList` interna a través de un método `getGridList()` para que los controladores puedan interactuar con ella.

1.2. Creación del Renderer de Celdas del Grid:
    - Nombre del archivo: `vista/renderers/GridCellRenderer.java`
    - Heredará de: `JPanel` e implementará `ListCellRenderer<String>`.
    - Se basará en el diseño y la lógica de `MiniaturaListCellRenderer.java`.
    - Responsabilidades:
        - Dibujar una única celda del grid.
        - Mostrar una miniatura de un tamaño predefinido (ej. 128x128).
        - Obtener la miniatura a través del `ThumbnailService` existente. Se decidirá si estas miniaturas más grandes se cachean o no (propuesta inicial: no cachear para proteger el LruCache, confiando en la velocidad del escalado).
        - Mostrar el nombre del archivo debajo de la miniatura, con gestión de saltos de línea para nombres largos (usando HTML).
        - Gestionar la apariencia visual de la selección (color de fondo, borde).

1.3. Integración en `ViewBuilder.java`:
    - Localizar el método `createRightSplitComponent()`.
    - Reemplazar el `JPanel` placeholder de "VISTA_GRID" por una instancia real de `new GridDisplayPanel(...)`.
    - Registrar el nuevo panel en `ComponentRegistry` con la clave `"panel.display.grid"`.
    - Registrar la `JList` interna del panel en `ComponentRegistry` con la clave `"list.grid"`.

======================================================================
== FASE 2: LÓGICA DE CONTROL Y SINCRONIZACIÓN
======================================================================

2.1. Orquestación del Cambio de Modo (en `GeneralController` o similar):
    - Se creará un método (ej. `switchToDisplayMode(DisplayMode newMode)`) que centralice la lógica.
    - Responsabilidades de este método al cambiar a MODO_GRID:
        a. Poblar el Grid: Obtener la lista de claves de imagen del `VisorModel` (`model.getCurrentListContext().getModeloLista()`) y pasarla al `GridDisplayPanel` (`gridDisplayPanel.setImageKeys(...)`).
        b. Cambiar la Vista: Llamar a `viewManager.cambiarAVista("container.displaymodes", "VISTA_GRID")`.
        c. Sincronizar Selección: Obtener el índice actual del `VisorModel` (`model.getIndiceActual()`) y usarlo para seleccionar y hacer visible el elemento correspondiente en el `GridDisplayPanel`.
        d. Gestionar Visibilidad de Paneles (Lógica Inteligente):
            - Ocultar automáticamente la barra de miniaturas inferior (`scroll.miniaturas`) llamando al `ViewManager`.
            - Actualizar el estado del `JCheckBoxMenuItem` de "Mostrar Miniaturas" en el menú para que aparezca desmarcado.
            - Guardar el nuevo estado de visibilidad de las miniaturas en el archivo `config.cfg`.
        e. Persistir el Modo: Guardar el nuevo modo de visualización en `config.cfg` (ej. `ui.displaymode.lastUsed = "GRID"`).

2.2. Interacción del Usuario con el Grid:
    - Se añadirá un `ListSelectionListener` a la `JList` del `GridDisplayPanel`.
    - Evento de Clic Simple/Selección:
        - El listener notificará al `ListCoordinator` del nuevo índice seleccionado (`listCoordinator.seleccionarImagenPorIndice(newIndex)`).
        - El `ListCoordinator` se encargará de actualizar el modelo y sincronizar las otras vistas (si estuvieran visibles), como la lista de nombres.
    - Evento de Doble Clic:
        - Se añadirá un `MouseListener` a la `JList`.
        - Al detectar un doble clic, se cambiará de vuelta al modo de imagen única (`switchToDisplayMode(DisplayMode.SINGLE_IMAGE)`), mostrando la imagen en la que se hizo clic.

2.3. Sincronización Inversa (del `ListCoordinator` al `Grid`):
    - Se modificará el `ListCoordinator` (o un método que lo use) para que, además de sincronizar las listas existentes, también sincronice la selección en el grid si este está visible.
    - `listCoordinator.seleccionarImagenPorIndice()` llamará, indirectamente, a `sincronizarSeleccionJList(registry.get("list.grid"), index)`.

======================================================================
== FASE 3: FUNCIONALIDADES AVANZADAS Y REQUISITOS ESPECÍFICOS
======================================================================

3.1. Selección Múltiple (Estilo Explorador de Windows):
    - Se configurará la `JList` del `GridDisplayPanel` con `setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION)`.
    - Se aplicará la misma configuración a la `JList` de la lista de nombres (`list.nombresArchivo`) para añadir esta funcionalidad también en la vista principal.

3.2. Adaptación de Acciones para Procesamiento por Lotes:
    - Las acciones existentes (ej. "Marcar", "Descartar", "Exportar") deberán ser modificadas.
    - Su lógica deberá comprobar el modo de visualización actual.
    - Si el modo es `GRID`, la acción deberá operar sobre la lista de elementos seleccionados (`gridList.getSelectedValuesList()`) en lugar de sobre el único índice del modelo.

3.3. Barra de Herramientas Específica para el Grid (Post-implementación inicial):
    - Se diseñará y añadirá un `JToolBar` en la zona sur del `GridDisplayPanel`.
    - Contendrá controles para:
        - Aumentar/reducir el tamaño de las celdas (zoom del grid).
        - Navegación por páginas (siguiente/anterior), utilizando el valor de `salto de bloque` ya existente en la configuración.

3.4. Previsualización con Doble Clic (Post-implementación inicial):
    - En lugar de cambiar de modo, se podría implementar que el doble clic abra un `JDialog` modal.
    - Este diálogo contendría una instancia de `ImageDisplayPanel` para mostrar la imagen en un tamaño mayor, permitiendo zoom y paneo sin salir del modo Grid. Esta es una alternativa al punto 2.2.

======================================================================
== FIN DEL INFORME
======================================================================


============================================================
CLASES INVOLUCRADAS EN EL SISTEMA DE LA BARRA DE MINIATURAS
============================================================

--- Capa de la Vista (El "Cómo se ve") ---

1. vista.builders.ViewBuilder
   Funcion: Es el "arquitecto". Construye la JList y el JScrollPane de la barra de miniaturas y le asigna el MiniaturaListCellRenderer.

2. vista.renderers.MiniaturaListCellRenderer
   Funcion: Es el "pintor". Se encarga de dibujar cada celda individual de la lista, solicitando la imagen al ThumbnailService y aplicando los colores y bordes del tema actual.


--- Capa del Controlador (La "Lógica") ---

3. controlador.ListCoordinator
   Funcion: Es el "director de orquesta". Gestiona la lógica del "viewport" (qué miniaturas mostrar) y mantiene sincronizadas la selección en la lista de nombres, la barra de miniaturas y la imagen principal.

4. controlador.VisorController
   Funcion: Es el "controlador general". Inicia la carga de la lista de imágenes y sirve de nexo entre la vista, el modelo y los coordinadores/servicios.


--- Capa del Modelo (Los "Datos") ---

5. modelo.VisorModel
   Funcion: Es la "fuente de la verdad". Contiene la lista maestra completa con las rutas de todas las imágenes y el estado de la selección actual.


--- Capa de Servicios (Los "Trabajadores") ---

6. servicios.image.ThumbnailService
   Funcion: Es la "fábrica de miniaturas". Carga las imágenes desde el disco, las redimensiona al tamaño correcto y las guarda en un caché para un acceso rápido.

7. servicios.cache.LruCache
   Funcion: Es el "gestor de memoria" del ThumbnailService. Implementa el caché que almacena las miniaturas, descartando automáticamente las más antiguas para evitar un consumo excesivo de memoria.
   
***********************************************************************************************************************************************   























==================================================================================================================================================================
																TAREAS TERMINADAS
==================================================================================================================================================================


-------------------------------------------------------------------------
--- PLAN DE IMPLEMENTACIÓN COMPONENTE D-PAD ---
-------------------------------------------------------------------------

1. Objetivo Final:
Implementar un componente de UI DPadComponent reutilizable y genérico. La configuración de sus "hotspots" (zonas interactivas), su layout (cruz, grid, etc.) y su comportamiento se definirá de forma declarativa en UIDefinitionService, manteniendo el componente agnóstico al proyecto. El componente se usará para implementar una funcionalidad de paneo de imagen.

2. Principios de Diseño Acordados:
- Encapsulación Máxima: Toda la lógica de geometría, validación y dibujado de un layout específico (ej. una cruz) reside dentro de la clase DPadComponent.
- Independencia del Componente: DPadComponent es genérico. No conoce clases del proyecto como IconUtils o ActionFactory. Recibe objetos ya construidos (Image, Action).
- Definición Declarativa: La estructura y comportamiento de cada D-Pad se define en UIDefinitionService usando records de definición.
- Fábrica Explícita: Se usarán métodos de fábrica estáticos en DPadComponent (ej. createCrossLayout) para construir instancias con layouts predefinidos, garantizando la robustez y una API clara.
- Convención sobre Configuración: Se usarán constructores sobrecargados para que IconScope.THEMED sea el valor por defecto, reduciendo la verbosidad en las definiciones.

---
3. Plan de Acción Detallado (Clase por Clase):

PASO A: Crear/Modificar Clases de Definición (/vista/config/)

- IconScope.java:
  - Qué: Asegurarse de que el enum existe con los valores THEMED y COMMON.

- HotspotDefinition.java (NUEVO FICHERO):
  - Qué: Crear un nuevo record para definir un "ítem" de un D-Pad.
  - Cómo:
    package vista.config;
    public record HotspotDefinition(
        String comando,
        String tooltip,
        String icono,
        IconScope scope
    ) {
        // Constructor de conveniencia para asumir THEMED por defecto
        public HotspotDefinition(String comando, String tooltip, String icono) {
            this(comando, tooltip, icono, IconScope.THEMED);
        }
    }

- ButtonType.java:
  - Qué: Añadir tipos específicos para los layouts del D-Pad.
  - Cómo:
    public enum ButtonType {
        NORMAL,
        TOGGLE,
        TRANSPARENT,
        DPAD_CRUZ,
        DPAD_GRID;
        // ... etc.
    }

- ToolbarButtonDefinition.java:
  - Qué: Modificar el record para que pueda contener una lista de definiciones de hotspots y las dimensiones para layouts de grid.
  - Cómo:
    public record ToolbarButtonDefinition(
        String comandoCanonico,
        String claveIcono,
        IconScope scopeIconoBase, // Para el icono base del componente
        String textoTooltip,
        String categoriaLayout,
        ButtonType tipoBoton,
        List<HotspotDefinition> listaDeHotspots, // Para D-Pads
        int gridRows, // Para DPAD_GRID
        int gridCols  // Para DPAD_GRID
    ) {
        // Añadir varios constructores sobrecargados para simplificar la creación
        // de botones normales, toggles, etc., que no usan los últimos parámetros,
        // asignando null, 0, o valores por defecto.
    }

PASO B: Actualizar el Servicio de Definición de UI (/vista/config/)

- UIDefinitionService.java:
  - Qué: Implementar la definición declarativa de un D-Pad.
  - Cómo:
    1. Dentro de la clase, crear una List<HotspotDefinition> para el layout en cruz (ej. dpadPaneoItems), respetando un orden documentado (0:UP, 1:DOWN, 2:LEFT, 3:RIGHT).
    2. En generateModularToolbarStructure(), al definir el ToolbarButtonDefinition para el D-Pad, usar el nuevo constructor pasándole:
        - La lista dpadPaneoItems.
        - El ButtonType.DPAD_CRUZ.

PASO C: Refactorizar el Componente DPadComponent (/vista/components/)

- DPadComponent.java:
  - Qué: Convertir la clase para que use métodos de fábrica estáticos y encapsule toda la lógica de layout.
  - Cómo:
    1. Hacer el constructor principal private.
    2. Eliminar la clase interna Builder. Ya no es necesaria.
    3. Crear el método public static DPadComponent createCrossLayout(Dimension size, Image baseImage, Image pressedImage, List<Hotspot> hotspots).
    4. Dentro de createCrossLayout:
        - Validar que hotspots.size() es 4.
        - Validar que size es suficiente para una cuadrícula de 3x3.
        - Calcular los 4 Rectangle para la cruz.
        - Crear una List<Hotspot> final, combinando los Hotspot de entrada con los Rectangle calculados.
        - Llamar al constructor privado con todos los datos finales y devolver la instancia.

PASO D: Actualizar el Constructor de la UI (/vista/builders/)

- ToolbarBuilder.java:
  - Qué: Simplificar la creación del D-Pad para que llame al nuevo método de fábrica.
  - Cómo:
    1. En el switch de crearComponenteIndividual, añadir el case DPAD_CRUZ:.
    2. Dentro del case:
        - Obtener la List<HotspotDefinition> de la ToolbarButtonDefinition.
        - Crear una List<Hotspot> "pre-construidos" iterando sobre las definiciones. Para cada una, usar actionMap para obtener la Action y iconUtils para obtener la Image. Estos Hotspot se crearán con bounds = null.
        - Llamar al método de fábrica: return DPadComponent.createCrossLayout(new Dimension(32,32), baseImage, pressedImage, prebuiltHotspots);

PASO E: Implementar la Lógica de Negocio (/controlador/)

- GeneralController.java:
  - Qué: Implementar la lógica de paneo incremental que será llamada por las PanAction.
  - Cómo:
    1. Crear o modificar el método public void panImageIncrementally(Direction direction, int amount).
    2. Dentro de este método:
        - Obtener el VisorModel.
        - Comprobar si el paneo está habilitado (model.isZoomHabilitado()).
        - Si está habilitado, calcular el deltaX y deltaY según la direction y amount.
        - Llamar a model.addImageOffsetX(deltaX) y model.addImageOffsetY(deltaY).
        - Obtener el ImageDisplayPanel del ComponentRegistry.
        - Llamar a displayPanel.repaint().
        - Lógica Condicional: Si el paneo NO está habilitado, implementar la lógica alternativa (ej. navegar en la lista de archivos).
    3. Asegurarse de que el método panImageToEdge también tenga una implementación (puede llamar a panImageIncrementally con un valor grande o tener su propia lógica de cálculo de bordes si se necesita en el futuro).

Listado de Clases a Modificar y Crear
Fase 1: Creación de las Definiciones (Paquete: /vista/config/)
    HotspotDefinition.java - (FICHERO NUEVO)
Crearemos este nuevo record para definir los "ítems" de un D-Pad.
    IconScope.java - (Revisar/Crear)
Nos aseguraremos de que este enum existe con los valores THEMED y COMMON.
    ButtonType.java - (Modificación)
Añadiremos los nuevos tipos DPAD_CRUZ y DPAD_GRID al enum.
    ToolbarButtonDefinition.java - (Modificación)
Modificaremos el record para que pueda aceptar los nuevos parámetros (listaDeHotspots, gridRows, gridCols, scopeIconoBase).
Añadiremos los constructores sobrecargados para mantener la simplicidad en las definiciones de botones normales.
Fase 2: Implementación de las Definiciones (Paquete: /vista/config/)
    UIDefinitionService.java - (Modificación)
Crearemos las listas de HotspotDefinition (los "planos").
Actualizaremos la llamada al constructor de ToolbarButtonDefinition para el D-Pad, pasándole los nuevos parámetros.
Fase 3: Refactorización del Componente y su Constructor (Paquetes: /vista/components/ y /vista/builders/)
    DPadComponent.java - (Modificación Mayor)
Haremos su constructor private.
Eliminaremos la clase anidada Builder.
Añadiremos el método de fábrica estático public static DPadComponent createCrossLayout(...).
    ToolbarBuilder.java - (Modificación)
Refactorizaremos el switch en el método crearComponenteIndividual para añadir el case DPAD_CRUZ:.
Implementaremos la lógica dentro de ese case para que prepare los Hotspot y llame al nuevo método de fábrica estático de DPadComponent.
Fase 4: Implementación de la Lógica Final (Paquete: /controlador/)
    GeneralController.java - (Modificación)
Implementaremos el código final dentro del método public void panImageIncrementally(...). Será el corazón de la funcionalidad de movimiento.
(Posiblemente, también modificaremos panImageToEdge para que llame al método incremental o tenga una implementación básica).



Sugerencias de Mejora
1. Validación y Gestión de Errores
En createCrossLayout, la validación de hotspots.size() == 4 es buena, pero podrías:

Lanzar una excepción específica (ej. InvalidLayoutException) con mensaje descriptivo.

Considerar logs de advertencia en lugar de solo errores duros si quieres permitir flexibilidad futura.

2. Flexibilidad de Layouts
Actualmente soportas DPAD_CRUZ y DPAD_GRID, pero podrías prever:

Layouts diagonales o en círculo (para rotaciones u otras funciones).

Agregar una interfaz como DPadLayoutStrategy para permitir layouts personalizados en el futuro.

3. Internacionalización
¿Los tooltips y textos visibles estarán internacionalizados?

Tal vez HotspotDefinition debería recibir una keyTooltip y delegar la traducción a otro servicio.

4. Unit Tests
No se menciona testeo. Te recomendaría diseñar pruebas para:

DPadComponent.createCrossLayout

Lógica de paneo en GeneralController

Serialización/deserialización de definiciones en UIDefinitionService

5. Animaciones o Feedback Visual
¿Consideras agregar feedback visual al presionar los "hotspots"? (por ejemplo, un sombreado, sonido, vibración si es móvil). Esto mejora mucho la UX.

6. Extensión con Iconos Dinámicos
Podrías permitir iconos cambiantes por estado (ej. presionado/no presionado) desde la definición, agregando más expresividad a HotspotDefinition.

-------------------------------------------------------------------------
--- FIN DEL PLAN DE IMPLEMENTACIÓN COMPONENTE D-PAD ---
-------------------------------------------------------------------------


-------------------------------------------------------------------------
--- PLAN DE IMPLEMENTACIÓN SELECCIÓN DE PROYECTO ---
-------------------------------------------------------------------------

== Plan Detallado para la Funcionalidad de "Selección de Imágenes para Proyecto" ==

OBJETIVO PRINCIPAL:
Permitir al usuario marcar imágenes individuales de interés dentro de un directorio
grande, guardar esta selección como un "proyecto", y poder ver/cargar estas
selecciones posteriormente. Esto es para ayudar en proyectos de impresión 3D
donde las imágenes representan los archivos STL.

TERMINOLOGÍA:
- "Selección de Proyecto" o "Imágenes Marcadas": El conjunto de imágenes que el usuario ha marcado.
- "Archivo de Proyecto": El archivo en disco (ej. .prj, .txt) que guarda una Selección de Proyecto.
- "Archivo de Selección Temporal": Un archivo por defecto donde se guardan las marcas si no se ha guardado/cargado un proyecto.

============================
ITERACIÓN 1: FUNCIONALIDAD BÁSICA (Archivo Temporal Único, Marcar/Desmarcar, Ver Lista Simple)
============================

1. ProjectSelectionManager (Clase Principal):
   - Campos:
       - `private final Path archivoSeleccionTemporal = Paths.get(System.getProperty("user.home"), ".miVisorImagenes", "seleccion_temporal.txt");`
         (Asegurar que el directorio `~/.miVisorImagenes` se cree si no existe).
       - `private Set<String> clavesMarcadasEnMemoria;` (claves relativas de imágenes).
   - Constructor:
       - Llama a `cargarDesdeArchivo(archivoSeleccionTemporal)` para poblar `clavesMarcadasEnMemoria`.
   - Métodos Privados:
       - `cargarDesdeArchivo(Path rutaArchivo)`: Lee el archivo, llena `clavesMarcadasEnMemoria`. Maneja si el archivo no existe.
       - `guardarAArchivo(Path rutaArchivo, Set<String> claves)`: Escribe el Set al archivo, una clave por línea.
   - Métodos Públicos:
       - `marcarImagen(String claveRelativa)`:
           - Añade `claveRelativa` a `clavesMarcadasEnMemoria`.
           - Llama a `guardarAArchivo(archivoSeleccionTemporal, clavesMarcadasEnMemoria)`.
       - `desmarcarImagen(String claveRelativa)`:
           - Quita `claveRelativa` de `clavesMarcadasEnMemoria`.
           - Llama a `guardarAArchivo(archivoSeleccionTemporal, clavesMarcadasEnMemoria)`.
       - `estaMarcada(String claveRelativa)`:
           - Devuelve `clavesMarcadasEnMemoria.contains(claveRelativa)`.
       - `getClavesMarcadas()`:
           - Devuelve `new ArrayList<>(clavesMarcadasEnMemoria)` (o una copia inmutable).
       - `alternarMarcaImagen(String claveRelativa)`:
           - Si `estaMarcada`, llama a `desmarcarImagen`. Sino, llama a `marcarImagen`.
           - Devuelve el nuevo estado (true si quedó marcada, false si desmarcada).

2. AppActionCommands:
   - `CMD_PROYECTO_TOGGLE_MARCA = "cmd.proyecto.toggle_marca";`
   - `CMD_PROYECTO_MOSTRAR_SELECCION_DIALOGO = "cmd.proyecto.mostrar_seleccion_dialogo";` // Para el JOptionPane inicial

3. Nuevas Actions (en controlador.actions.proyecto o similar):
   - `ToggleMarkImageAction extends BaseVisorAction`:
       - Comando: `CMD_PROYECTO_TOGGLE_MARCA`.
       - Icono: `5003-marcar_imagen_48x48.png` (o el nombre final).
       - Tooltip: "Marcar/Desmarcar imagen para el proyecto actual".
       - `actionPerformed`:
           - Obtiene `selectedImageKey` del `VisorModel`.
           - Si no es null, llama a `controller.toggleMarcaImagenActual(selectedImageKey);` (nuevo método en controller).
   - `ShowProjectSelectionDialogAction extends BaseVisorAction`:
       - Comando: `CMD_PROYECTO_MOSTRAR_SELECCION_DIALOGO`.
       - Icono: `7003-Mostrar_Favoritos_48x48.png` (o el nombre final).
       - Tooltip: "Mostrar imágenes marcadas para el proyecto actual".
       - `actionPerformed`:
           - Llama a `controller.mostrarDialogoSeleccionProyectoActual();` (nuevo método en controller).

4. VisorController:
   - Añadir campo: `private ProjectSelectionManager projectManager;` (inicializar en `AppInitializer`).
   - Inicializar `toggleMarkImageAction` y `showProjectSelectionDialogAction`. Añadirlas al `actionMap`.
   - Nuevo método: `public void toggleMarcaImagenActual(String claveImagen)`:
       - Llama a `projectManager.alternarMarcaImagen(claveImagen)` para obtener `boolean nuevoEstadoMarcada`.
       - Actualiza `toggleMarkImageAction.putValue(Action.SELECTED_KEY, nuevoEstadoMarcada);`.
       - Llama a `actualizarEstadoVisualBotonMarcarYBarraEstado(nuevoEstadoMarcada);` (nuevo método).
   - Nuevo método: `public void actualizarEstadoVisualBotonMarcarYBarraEstado(boolean estaMarcada)`:
       - Llama a `view.actualizarAspectoBotonToggle(toggleMarkImageAction, estaMarcada);`.
       - Actualiza `view.setTextoRuta()` para añadir/quitar "[MARCADA]".
   - Nuevo método: `public void mostrarDialogoSeleccionProyectoActual()`:
       - Llama a `projectManager.getClavesMarcadas()`.
       - Construye un String con estas claves.
       - Muestra el String en un `JOptionPane.showMessageDialog`.
   - En `actualizarImagenPrincipal(int indiceSeleccionado)`:
       - Después de cargar la imagen y actualizar el modelo, obtener `selectedImageKey`.
       - Llamar a `boolean marcada = projectManager.estaMarcada(selectedImageKey);`.
       - Llamar a `actualizarEstadoVisualBotonMarcarYBarraEstado(marcada);`.

5. UIDefinitionService:
   - `generateMenuStructure()`:
       - En Menú "Imagen": `new MenuItemDefinition(AppActionCommands.CMD_PROYECTO_TOGGLE_MARCA, MenuItemType.CHECKBOX_ITEM, "Marcar para Proyecto", null)`
       - En Menú "Vista" (o nuevo menú "Proyecto"): `new MenuItemDefinition(AppActionCommands.CMD_PROYECTO_MOSTRAR_SELECCION_DIALOGO, MenuItemType.ITEM, "Ver Selección de Proyecto", null)`
   - `generateToolbarStructure()`:
       - Botón "Marcar": `new ToolbarButtonDefinition(AppActionCommands.CMD_PROYECTO_TOGGLE_MARCA, "5003-marcar_imagen_48x48.png", "Marcar/Desmarcar Imagen", "control")` (o la categoría que prefieras).
       - Botón "Mostrar Selección": `new ToolbarButtonDefinition(AppActionCommands.CMD_PROYECTO_MOSTRAR_SELECCION_DIALOGO, "7003-Mostrar_Favoritos_48x48.png", "Mostrar Imágenes Marcadas", "control")` (o la categoría que prefieras).

6. VisorView (Opcional para Iteración 1, pero bueno para el futuro):
   - Si `ToggleMarkImageAction` no cambia el icono del botón directamente, `actualizarAspectoBotonToggle` podría necesitar lógica para cambiar entre icono de estrella vacía/llena.

============================
ITERACIÓN 2: GESTIÓN DE PROYECTOS CON NOMBRE (Guardar Como, Abrir, Nuevo)
============================

1. ProjectSelectionManager:
   - Campo: `private Path archivoProyectoActivo;` (puede ser null si es el temporal).
   - Modificar constructor y métodos para usar `archivoProyectoActivo` si no es null, sino `archivoSeleccionTemporal`.
   - `nuevoProyecto()`: `clavesMarcadasEnMemoria.clear(); archivoProyectoActivo = null; guardarAArchivo(archivoSeleccionTemporal, ...);` Actualizar título de ventana.
   - `guardarProyectoComo(Path destino)`: `guardarAArchivo(destino, clavesMarcadasEnMemoria); archivoProyectoActivo = destino;` Actualizar título.
   - `abrirProyecto(Path origen)`: `cargarDesdeArchivo(origen); archivoProyectoActivo = origen;` Actualizar título.
   - `hayCambiosSinGuardar()`: Compara `clavesMarcadasEnMemoria` con el contenido de `archivoProyectoActivo` (si existe).

2. AppActionCommands:
   - `CMD_PROYECTO_NUEVO`, `CMD_PROYECTO_ABRIR`, `CMD_PROYECTO_GUARDAR_COMO`, `CMD_PROYECTO_GUARDAR` (si el proyecto activo tiene nombre).

3. Nuevas Actions: `NuevoProyectoAction`, `AbrirProyectoAction`, `GuardarProyectoComoAction`, `GuardarProyectoAction`.

4. VisorController:
   - Métodos para manejar estas nuevas acciones, usando `JFileChooser` para guardar/abrir.
   - Lógica para "Guardar" (si `archivoProyectoActivo` no es null, guarda ahí; sino, actúa como "Guardar Como").
   - Modificar `ShutdownHook`: Si `projectManager.hayCambiosSinGuardar()`, preguntar al usuario si desea guardar antes de salir. Si guarda, y es temporal, preguntar si quiere darle nombre. Si no guarda y es temporal, se podría borrar `archivoSeleccionTemporal`.
   - Actualizar título de la `JFrame` (`VisorView`) para incluir el nombre del proyecto activo o "(Temporal)".

5. UIDefinitionService:
   - Nuevo Menú "Proyecto" con ítems para Nuevo, Abrir, Guardar, Guardar Como.

============================
ITERACIÓN 3: VISTA INTEGRADA DE SELECCIÓN DE PROYECTO (Toggle de ListModel)
============================

1. AppActionCommands:
   - `CMD_PROYECTO_TOGGLE_VISTA_SELECCION = "cmd.proyecto.toggle_vista_seleccion";`

2. Nueva Action: `ToggleVistaSeleccionProyectoAction extends BaseVisorAction`.
   - `actionPerformed` llama a `controller.toggleVistaSeleccionProyecto();`.
   - Mantiene `Action.SELECTED_KEY` para el estado del toggle.

3. VisorModel:
   - `private boolean mostrandoSeleccionProyecto = false;`
   - `private DefaultListModel<String> modeloListaCarpetaOriginal;`
   - `private String claveSeleccionadaEnCarpetaOriginal;`

4. VisorController:
   - `toggleVistaSeleccionProyecto()`:
       - Invierte `model.mostrandoSeleccionProyecto`.
       - Actualiza `Action.SELECTED_KEY` de `ToggleVistaSeleccionProyectoAction`.
       - Llama a `actualizarAspectoBotonToggle(...)` para el botón de la toolbar.
       - Llama a `refrescarVistaPrincipalSegunModo();` (nuevo método).
   - `refrescarVistaPrincipalSegunModo()`:
       - Si `model.mostrandoSeleccionProyecto`:
           - Guarda `model.getModeloLista()` en `model.modeloListaCarpetaOriginal`.
           - Guarda `model.getSelectedImageKey()` en `model.claveSeleccionadaEnCarpetaOriginal`.
           - Obtiene `projectManager.getClavesMarcadas()`.
           - Crea `nuevoModeloSeleccion` a partir de esas claves.
           - Llama a `model.setModeloLista(nuevoModeloSeleccion);` (¡OJO! Este método debe ser cuidadoso para no limpiar `selectedImageKey` si la clave anterior está en el nuevo modelo).
           - Llama a `view.setListaImagenesModel(nuevoModeloSeleccion);` (o que `cargarListaImagenes` lo haga).
           - Llama a `cargarListaImagenes(primeraClaveDeSeleccionSiExiste)`.
           - Cambia título del panel izquierdo: "Selección: [Nombre Proyecto]".
       - Else (volviendo a vista de carpeta):
           - Llama a `model.setModeloLista(model.modeloListaCarpetaOriginal);`.
           - Llama a `view.setListaImagenesModel(...)`.
           - Llama a `cargarListaImagenes(model.claveSeleccionadaEnCarpetaOriginal)`.
           - Cambia título del panel izquierdo: "Lista de Archivos".

5. UIDefinitionService:
   - Botón en Toolbar para `CMD_PROYECTO_TOGGLE_VISTA_SELECCION`.
   - Ítem de Menú (quizás `JCheckBoxMenuItem`) en "Vista" para `CMD_PROYECTO_TOGGLE_VISTA_SELECCION`.

============================
CONSIDERACIONES ADICIONALES (Futuras):
============================
- **Modo Grid y Marcar:** Deshabilitar `ToggleMarkImageAction` general. Añadir menú contextual en el grid.
- **Rendimiento:** Si `getClavesMarcadas()` es muy grande y se llama frecuentemente para la UI, optimizar.
- **Multi-selección para Marcar/Desmarcar:** En `listaNombres` o Grid.
- **Internacionalización (i18n)** de todos los textos.
- **Deshacer/Rehacer** para marcado/desmarcado.


-------------------------------------------------------------------------
--- FIN DEL PLAN DE IMPLEMENTACIÓN SELECCIÓN DE PROYECTO ---
-------------------------------------------------------------------------







