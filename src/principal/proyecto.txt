1. - OBJETIVO DE ESTA SESIÓN:
[Aquí describes qué quieres lograr hoy. Ej: "Implementar la lógica para que el botón 'Exportar a PDF' genere un archivo con los datos de la tabla de clientes."]

2. - CONTEXTO GENERAL DE LA APLICACIÓN:

1. OBJETIVO DEL PROYECTO:
Aplicación de escritorio para visualizar, catalogar y gestionar una gran colección (~26,000+) de imágenes asociadas a modelos 3D. El objetivo principal es agilizar la búsqueda y organización de estos recursos.
2. ARQUITECTURA Y PRINCIPIOS DE DISEÑO:
Tecnología: Java, Swing (UI), Maven (Gestión de proyecto).
Layout Principal: CardLayout para cambiar entre los diferentes "modos" de la aplicación (Visualizador, Proyectos, Catalogador). La UI se compone de paneles modulares cuya visibilidad es configurable.
Barras de Herramientas: Múltiples JToolBar independientes que se muestran/ocultan según el contexto de la tarea actual.
Configuración y Futuro MegaConfig:
Actualmente, la configuración se gestiona a través de un archivo config.cfg.
Directriz de Diseño Clave: Todas las nuevas funcionalidades y refactorizaciones deben diseñarse de forma modular y flexible para facilitar su futura integración en una interfaz gráfica de configuración centralizada (MegaConfig). El código no debe tener valores "hard-coded" que luego sean difíciles de externalizar.
3. MÓDULOS PRINCIPALES:
A) Visualizador de Imágenes:
Vista Principal: Compuesta por tres paneles:
Lista de Nombres (JList): Muestra todos los nombres de archivo de la selección actual.
Barra de Miniaturas (JPanel con JScrollPane): Muestra un subconjunto de imágenes en miniatura para navegación rápida.
Visor Central: Muestra la imagen seleccionada a tamaño completo.
Lógica de Miniaturas (Crítico):
No se renderizan todas las miniaturas a la vez por rendimiento.
Se gestiona un "viewport" de miniaturas: al hacer scroll, se eliminan las miniaturas que salen de la vista y se añaden las nuevas.
Existe un sistema de caché de miniaturas para agilizar la carga.
El número de miniaturas visibles es dinámico y se adapta al ancho de la ventana.
Funcionalidades: Zoom (manual y predefinido), navegación por carpetas (con/sin subcarpetas), modos de visualización (Grid, Pantalla Completa, Carrusel), edición básica (rotar, espejo, recortar).
B) Gestor de Proyectos:
Permite marcar imágenes de interés.
Las imágenes marcadas se añaden a una lista temporal (ej. un archivo de texto).
Permite visualizar y gestionar estas listas como "proyectos" guardados.
C) Catalogador de Imágenes (Futuro/Grueso del proyecto):
Funcionalidad principal a largo plazo.
Utilizará una base de datos o metadatos para permitir búsquedas por etiquetas/tags (ej. "elfo", "skaven").
El objetivo es superar la limitación de la estructura de carpetas.
4. SINCRONIZACIÓN DE LISTAS:
Existe una lista de datos principal (el "modelo") que contiene la información de los archivos en disco.
Esta lista principal alimenta tanto a la JList de nombres como a la barra de miniaturas.
Un método de sincronización se encarga de que la selección en una lista se refleje correctamente en la otra y en el visor principal.


3. - DIRECTRICES INQUEBRANTABLES (Nuestras Reglas de Trabajo):
Regla 1 (CÓDIGO REAL): Trabaja siempre con el código real. Antes de darme un código basado en lo que supuestamente hace una clase/método, PIDE LA CLASE. No asumas ninguna implementación.
Regla 2 (COMENTARIOS): Añade siempre los comentarios de final de bloque // ---FIN de metodo [nombre]---  y // --- FIN de clase [nombre]---
Regla 3 (SIN RENOMBRAR): No se pueden cambiar los nombres de variables, métodos o clases que ya existen.
Regla 4 (NO REFACTORIZAR): No refactorices ni simplifiques métodos existentes sin consultarme primero. Céntrate únicamente en la tarea solicitada.
Regla 5 Formato de Entrega: Formato estándar de "busca y reemplaza" o "añade debajo". Es más claro y seguro para ambos.

4. - ESTRUCTURA DEL PROYECTO (dir /b /s):



**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************



	el github es: https://github.com/JavierTortosa/catalogador-imagenes-java.git
	
	este es un proyecto de un visualilzador/catalogador en java/swing (ahora maven/swing). 
	
	Idea general:
	Soy aprendiz de programador y me dedico bastante a menudo a hacer proyectos en 3d. 
	
	Este proyecto nace de la ncesidad de buscar entre cerca de 26000 imagenes.
	Cada una de estas imagenes corresponde a un archivo comprimido que es quien contiene los modelos a imprimir
	
	Los archivos estan separados por carpetas tematicas, las cuales pueden contener varios temas diferentes y de varias formas diferentes
	Para aclararnos, las carpetas pueden ser de cine, herramientes, escenografia, etc., y dentro de cada carpeta puede contener mas carpetas refinando el catalogo de archivos
	El problema es que puede ser por una tematica, cine, o puede ser por un diseñador, punga, o simplemente ser archivos stl con su imagen
	las carpetas tematicas no tienen demasiado problema, pero las de diseñadores pueden contener varios temas, ademas las imagenes pueden ser de 1 modelo o varios
	
	Los proyectos en 3d suelen ser tematicos por ej trofeos para toneo de blood bowl. para este proyecto necesitare buscar: bases, pedestales, una base superior y un modelo que represente el campeon por ej...
	Todo lo referente a trofeos esta en la carpeta trofeos, dentro hay otras carpetas de bases, pedestales, etc... 
	Luego tengo que ir buscando la figura que ira encima del toreo en funcion de la tematica del torneo, pongamos skaven. 
	El kit de la cuestion es buscar entre las 26000 imagenes, algun modelo que sea de la tematica que busco y que me sirva para el trofeo... 
	
	Lo que pretendo con este proyecto es poder agilizar dicha busqueda.


El programa:

El programa tiene 3 partes:
	Visualizador
	Gestor de proyectos
	catalogador de imagenes
	
Este es el orden en el que pretendo abordar el proyecto, ya que primero necesito un programa agil y rapido que me permita visualizar las imagenes rapidamente
En este punto tenemos varias herramientas:


-- El Visualizador --

	La interfaz:
		En la parte superior tiene un menu con la totalidad de opciones disponibles en el programa y una opcion de configuracion que en un futuro sera mucho mas completa
		A continuacion la barra de botones, que iran distribuidos en varias barras de herramientas y que segun donde estemos se mostraran unas herramientas u otras
			(no tiene ningun sentido que se visualicen los botones de movimiento en el carrousel si estamos editando una imagen) 
		En el centro de la aplicacion tenemos 3 partes:
			1. la lista de nombres de archivos (por si sabemos el nobmre de lo que buscamos y ordenacion de los archivos (nombre, carpeta, fecha...)
			2. la lista de miniaturas es la misma lista de nombres pero mostrando una pequeña lista de imagenes para navegacion rapida 
			3. vista de la imagen seleccionada. es la vista principal de la imagen seleccionada
		
	Formas de visualizar la interfaz 
		
		1. Navegador por carpetas, un selector de carpetas donde empezar la visualizacion de las imagenes
		2. Una opcion para que Se puede visualizar la carpeta actual o con las subcarpetas. muy util por la distribucion de las carpetas que tenemos
		3. Zoom. Hay 2 tipos:
			1. Zoom Manual que me permite acercar o alejar la imagen o moverla (muy practico en las imgaenes multiples)
			2. Tipos de zoom: son varias formas de ver las imagenes (sin restriccciones, ajutas al espacion maximo, ajustar al alto/ancho....)
				Este segundo tipo tiene una opcion para mantener o no las proporciones de la imagen
		2. Modos de visualizacion: 1 imagen, grid de imagenes, etc....
		3. Complemento al Modo de visualizacion: pantalla compeleta y carrousel
		4. Tanto el menu, como las diferentes listas, botones, etc se pueden hacer visibles o no... para ganar espacio de visualizacion
	
	Edicion
	
		1. la funciones basicas, rotar izq. y der., espejo horizonta y vertical
		2. Un modo de recortar (para las imagenes multiples) pero que sera capaz de de poder modificar la imagen actual 
			(tendra una serie de opciones para pegar el recorte en la imagen original, separar el recorte de la imagen original....)
		3. Varias formas de guardado tanto de la imagen nueva como la original como la modificacion.... 
		

-- Gestor de Proyectos --
					
	Se distribuye en varias fases: 
		1. una opcion de marcar las imagenes que nos interesa y añadir el archivo con su ruta en un txt temporal 
		2. Un visualizador de las imagenes marcadas (cambiando el foco entre las carpetas del disco o el contenido del txt)
		3. El archivo temporal se puede guardar con un nombre concreto y se pueden gestionar los diferentes proyectos
		
		
-- Catalogador de Imagenes --

	Es el grueso de la aplicacion, gestionando una base de datos o metadatos o algo similar en donde poder catalogar las imagenes, de tal forma que pueda buscar elfos, enanos, etc.
	Con la base de datos podremos implementar un gestor de proyectos que pueda ser mas refinado, el uso de tags, pero el trabajo de introducir los de 26000 imagenes puede ser duro.
	La complicacion mas grande de catalogar las imagenes es el tema de que la cantidad de archivos que tengo ahora y que va creciendo y por lo tanto se van refinando las carpetas
		(una carpeta que empezo siendo cine, ahora tiene star wars, señor de los anillos.... y dentro de star wars esta la carpeta de naves, personajes, droides... y asi hasta el infinito....

		 
--- MegaConfig - El Centro de Control del Usuario:

	Objetivo: Proporcionar una interfaz gráfica centralizada donde el usuario pueda ajustar finamente casi todos los aspectos del comportamiento y la apariencia de la aplicación, sin necesidad de editar manualmente el archivo config.cfg (aunque este seguirá siendo la base para la persistencia).

	Contenido Potencial (basado en lo que ya tienes y planeas):
		Visibilidad de Componentes de UI:
		Checkboxes para mostrar/ocultar la barra de menú, la barra de herramientas principal, la lista de archivos, la barra de miniaturas, las barras de información (superior e inferior) y los elementos individuales dentro de estas barras.
		Gestión de la visibilidad de botones individuales en la barra de herramientas (lo que ya tienes en el menú "Configuración -> Visualizar Botones" podría migrar o complementarse aquí).

	Configuración de Paneles y Layout:
		(Más avanzado) Opciones para cambiar la disposición de los paneles principales si decides ofrecer diferentes layouts.
		Configuración de la posición por defecto del divisor del JSplitPane.

	Comportamiento de la Aplicación:
		Opciones de "Carga de Imágenes" (subcarpetas, ordenación por defecto).
		Opciones de "Comportamiento General" (imagen de bienvenida, abrir última imagen, navegación circular, etc.).
		Configuración de la cantidad de miniaturas (antes/después), tamaño de miniaturas.
		Parámetros de zoom por defecto.

	Apariencia y Temas:
		Selector de temas (lo que ya tienes en el menú, pero podría tener una vista previa aquí).
		(Muy avanzado) Editor de temas o personalización de colores individuales si quisieras ir por ese camino, aunque gestionar un tema completo es más sencillo.
		Configuración de Teclado (Atajos):
		(Avanzado) Permitir al usuario personalizar algunos atajos de teclado.
		Configuración de la Base de Datos/Catalogador (Futuro):
		Ruta de la base de datos, opciones de indexación, etc.
		Botones de Acción: "Aplicar", "Cancelar", "Restaurar Defaults".
		
	--- Diseño de la UI
	
		La interfaz esta diseñada sobre un cardLayout que proporciona que cada modo tenga su interfaz como si fueran las paginas de un libro
		Sobre esta pagina estan establecidos unos paneles vacios para que en el futuro config podamos asignar el componente final al panel que queramos
		La barra de botones esta compuesta por varias toolbars independientes para poder ver la toolbar pertinente segun lo que estemos haciendo
		
	--- Diseño de las Listas
		
		Dado el gran volumen de imagnes, necesitamos formas de ver la mayor cantidad de imagnes en el menor tiempo posible y para eso tenemos las 2 listas, una de nombres y otra de miniaturas
		La lista de nombres contiene la lista completa de nombres que estamos viendo pero la lista de miniaturas solo esta mostrando una cantidad concreta en cada momento porque hacer 26000 miniaturas es una locura
		Como la lista de nombres y la de miniaturas funcionan de forma diferente, la lista de miniaturas se crea de forma manual, creando una miniatura y añadiendola a la barra de miniaturas
		Cuando nos movemos por esta lista de miniaturas, lo que estamos haciendo es eliminar la miniatura que ya no se ve y añadiendo una nueva (al principio o al final segun convenga)
		Para sincronizar las 2 listas, lo que tenemos es una lista principal que es la que realmente tiene la informacion del disco y la deriva a las 2 listas (miniaturas y nombres) y con un metodo lo sincronizamos todo
		Ademas para ayudarnos al desplazamiento de las miniaturas, usamos un scrollPane que nos da los medios para el desplazamiento, pero no contiene las miniaturas, sino el panel que creamos nosotros
		Tambien se creo un cache para que algunas de las miniaturas se fabriquen mientras estamos viendo las que estan en pantalla y asi agilizamos la barra de miniaturas
		En una version mas avanzada, se añadio que las miniaturas visibles fuera variable, de manera que se vean el maximo de miniaturas posible segun el ancho de la aplicacion


--------------------------------   		 
   		
Modos de trabajo

	Visualizador de imagenes
	Gestor de proyectos
	Catalogador de imagenes
	Carrousel
	Edicion de imagenes
	
	   		 
--------------------------------


| Modo de Zoom                | BMP false (Modo Normal / "Confía en mí")                                                            | BMP true (Modo Seguro / "Ayúdame a verla")                                                    |
|-----------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| Ajustar a Pantalla          | Muestra la imagen entera, sin salirse. (BMP es irrelevante)                                         | Muestra la imagen entera, sin salirse. (BMP es irrelevante)                                   |
| Ajustar a Ancho             | La imagen se escala para ocupar el 100% del ancho del panel, manteniendo su proporción.             | Si al ajustar al ancho se sale por alto, se re-escala para que quepa entera (aplica Ajustar a Pantalla). |
|                             | Puede salirse por alto.                                                                             |
| Ajustar a Alto              | La imagen se escala para ocupar el 100% del alto del panel, manteniendo su proporción.              | Si al ajustar al alto se sale por ancho, se re-escala para que quepa entera (aplica Ajustar a Pantalla).  |
|                             | Puede salirse por ancho.                                                                            |
| Zoom 100% (Tamaño Real)     | La imagen se muestra a su tamaño real (1:1). Puede salirse.                                         | Si al 100% se sale de la pantalla, se re-escala para que quepa entera (aplica Ajustar a Pantalla).  |
| Zoom Fijo (Mantener Actual) | Usa el zoomFactor guardado. Ignora los límites del panel.                                           | Usa el zoomFactor guardado. Ignora los límites del panel.                                     |
| Zoom Específico             | Usa el % guardado. Ignora los límites del panel.                                                    | Usa el % guardado. Ignora los límites del panel.                                              |
| Rellenar                    | (ÚNICO CASO DE DEFORMACIÓN) Estira para ocupar el 100% del panel.                                   | Igual que en modo normal. (BMP es irrelevante)                                                |   		 
   		 
   		 
--------------------------------

pongamos un ejemplo de caso real....
pongamos que estoy buscando imagenes para un proyecto, y encuentro una imagen que es estrecha y alta. ese tipo de imagenes se que corresponde a un distribuidor en concreto, pulso el boton de mostrar solo carpeta de la imagen actual, y activo el modo de zoom ajustar a lo ancho.... pero la imagen es muy grande, asi que la reduzco para verla un poco mejor a pesar de que sobresale por arriba y por abajo. las imagenes de ese distribuidor estan en una misma carpeta, por lo que se que mostrando la carpeta actual voy a ver muchas imagenes con este mismo estilo y que es muy probable que el zoom que acabo de ajustar con la rueda del raton y el modo ajustar al ancho me serviran para las siguientes imagenes... entonces aplico el zoom fijo. a partir de ahora tolas las mage3nes que vea seran con ese zoom, pero de repente me encuentro una imagen que no corresponde con el formato, asi que paso a zoom especificado, manteniendo el % de las imagenes que he estado viendo hasta ahora y puede acercar o alejar la imagen sin cambios en el %z. en cuanto pase a la siguiente se volvera a aplicar el zoom que tenemoe en el popup....

--------------------------------

pongamos otro uso real para que veas como funcionan los modos como si todo funcionase y todo estuviera terminado....
me piden que haga 6 trofeos para un torneo de blood bowl. el torneo es la Parabellum Cup, en honor a un bar que empezo con esto de los torneos y su logo eran unos skaven jugando... por lo tanto el tema principal es Skavens...

vale. abrimos el programa y nos enfrentamos a 26000 imagenes. con la ayuda de la base de datos del modo Datos, tenemos las imagenes con unas etiquetas (TAGS)
vale. como el tema es skaven, aplicamos un filtro positivo en "SKAVEN", de las 26000 ya solo se nos muestran 5000....
ahora aplicamos otro filtro "BIG GUY" para que nos enseñe las ratas mas gordas y lustrosas para nuestros trofeos, ahora se muestran 2000. porque solo se muestran de las 26000 imagenes las que son skaven y big guy
vamos mirando imagen por imagen y vamos marcando las que nos pueden interesar.... total seleccionamos 20, por ej.
vamos al modo proyecto, y empezamos a mirar las imagenes que hemos seleccionado, y empezamos a ver algunas seleccionadas que no nos convencen, las marcamos para desechar (que sera otra lista que es previa al borrado de estas marcas)
necesitamos en total 6, pero de las 20 que hemos seleccionado solo nos han convencido 4. entonces volvemos al modo visualizador
ahora aplicamos un filtro negativo "BIG GUY" ahora no queremos que se muestren los big guys,
ahora nos vamos a la carpeta de "juegos de mese/bloodBowl" vemos que las imagenes de skaven ya las habiamos visto y no nos han convencido, pues aplicamos otro filtro negativo de "SKAVEN" ahora solo se muestran las imagenes de la carpeta "Juegos de mesa/blooBowl" que no son ni skaven ni big guy.... ves por donde voy
encontramos una imagen que se llama "motosierra ratuna" esta no estaba con los skaven ni con los big guy por eso no la habiamos visto y ahora si la vemos....
como esta encontramos unas cuantas mas.... vamos al modo proyecto donde aun conservamos las candidatas que nos han convencido y las que no y ademas tambien estan las nuevas imagenes.... en este mismo momento todas las imagenes que estoy viendo son del mismo tema, skaven, pero unas tienen el tag y otras no.... pues pulso mi opcion de añadir tag en bloque y todas las que yo quiera tendran el nuevo tag "SKAVEN"....
una vez que he conseguido mis 6 imagenes puedo pulsar el boton de "busqueda y rescate" para que el programa se pasee por las 26000 imagenes y copie el archivo de imagen con el archivo comprimido que la acompaña a la carpeta que se le indique para modificar los stl, preprar los archivos de impresion, etc.....

el modo proyecto, ademas de reviar las imagenes con mas detenimiento, ya no tengo 26000 para mirar, solo tengo 40.... por lo tanto el modo zoom y el paneo son mas cruciales que en el modo visualizador.
por otro lado, el modo proyecto es una muy buena herramienta que complementa el modo datos, porque mientras estoy gestionando el proyecto actual, puedo añadir un tag comun a las imagenes que tengo marcadas "Todas estas imagenes tienen el tag " SKAVEN", y no solo eso sino que luego ademas puedo seleccionar un grupo para decir "este grupo que tengo marcado tienen el tag "CON ESPADA" por decir algo... estas otras "CON ARCO" lo que sea.... tags que me ayuden a aplicar filtros en las imagnees para no tener que buscar entre las 26000 imagenes que se dicen pronto.... (la semana que viene seguramente llegare a las 27000) que eso es otro tema que habra que abordar en su momento....
me explico?

--------------------------------

te voy a pasar la clase de inicio... desde ahi parte todo, quiero que vayas recorriendo el flujo del programa y me vayas pidiendo las clases que vayas necesitando inspeccionar....

a la hora de trabajar:
-te lo voy a decir asi, NO QUIERO, REPITO, NO QUIERO QUE ASUMAS EL FUNCIONAMIENTO DE NINGUNA CLASE NI METODO, TE PROHIBO TOTAL Y TERMINANTEMENTE QUE ASUMAS QUE UNA CLASE HACE ALGO O QUE DEBERIA CONTENER UN METODO O CUALQUIER INTENTO DE ASUMIR QUE ALGO ESTA SIN COMPROBARLO PRIMERO.... esta es la unica y mayor premisa que quiero que cumplas a rajatabla....ok?
-quiero que seas lo mas exacto posible, prefiero una respuesta clara y correcta antes que una respuesta rapida.
-quiero que me des metodos o bloques de codigo completos. no me valen lineas sueltas. los metodos tienen suficientes comentarios como para que me digas sustituye el bloque tal o por lo menos quiero que me des la linea de antes y despues del bloque de codigo que me das para modificar
- me gustaria que añadieras al final de cada metodo y cada clase añadas un comentario de fin de clase o lo que sea...
-cuando estemos discutiendo un problema, estamos comprobando las diferentes partes a las que afecta ese problema y posibles soluciones.... se que tienes muchas ganas de ayudar y por culpa de esas ganas sueles precipitar soluciones que al final no son validas porque yo puedo refutar una suposicion tuya con lo que la solucion se invalida. asi que cuando estemos discutiendo no pasamos al codigo hasta que el problema no este claro y estemos los 2 en la misma pagina, ok?


problemas y soluciones
1. primero te explico el problema y no pasamos al siguiente punto hasta que estemos de acuerdo
2. propones que puede ser 
3. miramos como abordar el problema y no pasamos al siguiente punto hasta que estemos de acuerdo
4. empezamos a aplicar la solucion. clase a clase, metodo a metodo.... NO ME DES LOS CAMBIOS DE 20 CLASES DE GOLPE


creo que esto es todo mi temario imperativo y me gustaria que lo siguieras lo mas filemente posible

-----------------------------------

ICONOS

https://www.streamlinehq.com/icons/core-duo-color 								-> Normales
https://www.streamlinehq.com/icons/streamline-colors?icon=ico_cqBlbF5QkFCCCVKo	-> A Color

https://www.streamlinehq.com/icons/core-duo-color/interface-essential









**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************



======================================================================
librerias externas para implementas
======================================================================
TwelveMonkeys ImageIO: Soporte extendido para formatos de imagen: PSD, TIFF, BMP, etc.		IMPLEMENTADA
FlatLaf: el estándar de oro para Look and Feels modernos en Swing							IMPLEMENTADA
Thumbnailator: para crear miniaturas fácilmente.											IMPLEMENTADA
Caffeine: Caché en memoria ultra rápida (mejor que HashMap + LRU manual).					IMPLEMENTADA

SQLite-JDBC: Base de Datos
JDBI o jOOQ: Para Interactuar con la Base de Datos

Resumen y Prioridades
---------------------
Imprescindibles para el "Modo Datos":
SQLite-JDBC: Para tener una base de datos sin complicaciones.
JDBI: Para hablar con esa base de datos sin volverte loco.

Mejoras de Calidad de Vida (muy recomendadas):
Thumbnailator (que ya mencionaste): Para miniaturas de alta calidad.
Caffeine (que ya mencionaste): Para un sistema de caché de nivel profesional.
Lombok: Para reducir drásticamente el código repetitivo.

Para Funcionalidad Avanzada (opcional, pero potente):
metadata-extractor: Si quieres empezar a leer metadatos incrustados en las imágenes.


----------------------------
Implementacion LoogerFactory
----------------------------

private static final Logger logger = LoggerFactory.getLogger(AppInitializer.class); 
logger.info
logger.debug
logger.warn
logger.error
------------------------------------------------------------------------------------------------------------------------------------
La Solución: Cambiar el Nivel del Log
-------------------------------------
El nivel de log (level) funciona como un filtro. Si pones un nivel, solo se mostrarán los logs de ese nivel y los de niveles superiores. La jerarquía es:
TRACE < DEBUG < INFO < WARN < ERROR
Si pones level="DEBUG", se muestra todo (DEBUG, INFO, WARN, ERROR).
Si pones level="INFO", solo se muestra INFO, WARN, y ERROR.
Si pones level="WARN", solo se muestra WARN y ERROR.
Si pones level="ERROR", solo se muestra ERROR.
Si pones level="OFF", no se muestra absolutamente nada.
------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------
FLATLAF

web para buscar componentes para cambiar el color: 
https://www.formdev.com/flatlaf/properties-files/



**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************

------------------------------------------------------------------
HOJA DE RUTA PARA IMPLEMENTAR LOS MODOS DE VISUALIZACIÓN DEL VISOR
------------------------------------------------------------------


OBJETIVO: Reflejar el estado real de la aplicación tras la revisión exhaustiva del código. Este documento sirve como guía para el desarrollo futuro.

******************************************************************
***               TAREAS PENDIENTES (TRABAJO POR HACER)          ***
******************************************************************

---
### FASE 1: REFINAMIENTO DE NAVEGACIÓN Y UX FUNDAMENTALES
---

*   **Ajuste Dinámico del Tamaño de Miniaturas**
    *   **ESTADO:** PENDIENTE (EN PROGRESO)
    *   **NOTA:** Se ha decidido que los botones de control de tamaño vivirán en la barra de herramientas "Vista" para mantener la consistencia en todos los modos. La definición de la UI (`UIDefinitionService`) ha sido actualizada para reflejar esto.
    *   **PLAN DE ACCIÓN RESTANTE:**
        1. Implementar la lógica en las `Actions` (`Increase/DecreaseThumbnailSizeAction` en `ActionFactory`) para que sean "inteligentes".
        2. La lógica debe comprobar el `WorkMode` y `DisplayMode` actuales para decidir si redimensionar:
           - El Grid del Modo Proyecto.
           - El Grid del Modo Visualizador.
           - La barra de miniaturas horizontal del Modo Visualizador.


---
### FASE 2: IMPLEMENTACIÓN DE NUEVOS `DisplayMode`S
---

*   **Selección Múltiple en Modo Grid de Proyecto**
    *   **ESTADO:** PENDIENTE
    *   **NOTA:** El modo Grid funciona, pero actualmente solo permite la selección de un único elemento.
    *   **PLAN DE ACCIÓN:**
        1. Cambiar el `ListSelectionModel` del grid a `MULTIPLE_INTERVAL_SELECTION`.
        2. Refactorizar las acciones del modo proyecto (ej. "Mover a Descartes") para que puedan operar sobre una lista de elementos seleccionados (`getSelectedValuesList()`) en lugar de uno solo.

*   **`DisplayMode.POLAROID` (Modo Polaroid)**
    *   **ESTADO:** PENDIENTE (BAJA PRIORIDAD)
    *   **NOTA:** Se mantiene como una mejora estética para el futuro. No es una prioridad para la funcionalidad principal.


---
### FASE 3: CONFIGURACIONES DE VISTA Y MANTENIMIENTO DEL ESTADO
---

*   **Comportamiento Contextual del Selector de Archivos (Botón "Abrir")**
    *   **ESTADO:** PENDIENTE
    *   **NOTA:** La acción "Abrir" de la barra de herramientas principal no es sensible al contexto.
    *   **PLAN DE ACCIÓN:** Modificar la `Action` "Abrir" para que:
        - En Modo Visualizador, abra un selector de DIRECTORIOS.
        - En Modo Proyecto, abra un selector de ARCHIVOS para proyectos (`.prj`).

*   **Habilitación/Deshabilitación Contextual de Acciones**
    *   **ESTADO:** PENDIENTE
    *   **NOTA:** Algunas acciones/menús del modo Visualizador siguen activos en el modo Proyecto, donde no tienen sentido (ej. "Cargar Subcarpetas").
    *   **PLAN DE ACCIÓN:** Crear un método en `GeneralController` que se llame al cambiar de modo y que actualice el estado `setEnabled(false)` de las acciones que no son relevantes para el contexto actual.


---
### FASE 4: EDICIÓN Y MANEJO AVANZADO DE ARCHIVOS
---

*   **Opción de "Mover" en Flujo de Trabajo de Ingestión (Exportación)**
    *   **ESTADO:** PENDIENTE
    *   **NOTA:** La exportación por COPIA de archivos funciona. La funcionalidad de MOVER archivos está pendiente y se ha identificado como parte de un futuro "modo datos" para la ingesta de nuevos lotes.

*   **Barra de Progreso para Búsqueda de Archivos Asociados**
    *   **ESTADO:** PENDIENTE
    *   **NOTA:** El `TaskProgressDialog` existe y se usa correctamente para la *exportación* de archivos. Sin embargo, la *búsqueda inicial de archivos asociados* al preparar la cola de exportación se ejecuta en el hilo principal y carece de barra de progreso, lo que puede congelar la UI.
    *   **PLAN DE ACCIÓN:** Envolver la lógica de `ExportQueueManager.prepararColaDesdeSeleccion()` en un `SwingWorker` y mostrar el `TaskProgressDialog` durante su ejecución.

*   **Herramienta de Recorte (Cropping Tool) y Gestión de Guardado**
    *   **ESTADO:** POSPUESTO (BAJA PRIORIDAD)
    *   **NOTA:** Se considera un subproyecto complejo y no es prioritario para la funcionalidad principal de catalogación y gestión.


******************************************************************
***         TAREAS COMPLETADAS O DESCARTADAS (HISTORIAL)       ***
******************************************************************

*   **Persistencia del Estado de Visualización:** COMPLETADO. La aplicación ahora guarda y carga correctamente la última carpeta e imagen vistas en el modo Visualizador, independientemente del modo en que se cierre la app.

*   **Salto de Carpeta (Folder Skipping):** DESCARTADO. Se ha determinado que la funcionalidad es obsoleta y no necesaria.

*   **Control de Paneo con Atajos de Teclado (Ctrl+Alt):** DESCARTADO. La tecla `Alt` entra en conflicto con la funcionalidad estándar de menús de Swing, y la funcionalidad es redundante con el atajo `Numpad 8` que ya activa el modo de paneo.

*   **Desactivación Visual de Carga Rápida (Debounced Loading):** COMPLETADO. Se confirmó que el sistema existente de carga asíncrona con cancelación de tareas (`Future.cancel()`) en `VisorController` cumple eficazmente el objetivo de mantener la fluidez durante la navegación rápida.

*   **Menú Contextual (Popup Menu):** COMPLETADO. Se ha verificado que la funcionalidad está implementada y es correcta.

*   **Vista de Árbol de Carpetas (Folder Tree):** COMPLETADO. Se ha verificado que la funcionalidad ya existe en el código, contradiciendo la antigua hoja de ruta.

*   **`DisplayMode.CAROUSEL` (Carrusel/Filmstrip):** COMPLETADO. La funcionalidad está implementada y se ha reclasificado correctamente como un `WorkMode` (modo de trabajo) en sí mismo.

*   **Modo Pantalla Completa:** COMPLETADO. Se ha verificado que la funcionalidad existe y está correctamente implementada a través del `ViewManager`.

*   **Visibilidad de Componentes de UI:** COMPLETADO. El sistema para mostrar/ocultar paneles y barras de herramientas a través de `ToggleUIElementVisibilityAction` está implementado y funciona como se espera.

*   **Comportamiento Contextual de "Marcar Imagen":** COMPLETADO. Se ha verificado que la lógica de la acción "Marcar" cambia correctamente entre el modo Visualizador (marcar/desmarcar) y el modo Proyecto (mover a descartes/restaurar).

*   **Operaciones Básicas de Imagen (Rotación, Espejo):** COMPLETADO. Confirmado por el usuario.

*   **Exportación de Proyectos por Copia:** COMPLETADO. El `ExportWorker` implementa correctamente la lógica para copiar archivos de imagen y asociados a una carpeta de destino.


**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************



-------------------------------------------------------------------------
--- HOJA DE RUTA PARA IMPLEMENTAR EL MODO DATOS ---
-------------------------------------------------------------------------

Fase 1: Diseño y Arquitectura de la Base de Datos

1. Diseñar la estructura de la BD:
   - Tabla imagenes:
     - id (PK, autoincrement)
     - ruta (String, path completo en disco)
     - nombre_archivo (String)
     - fecha_modificacion
     - carpeta (posiblemente desglosada o sólo la carpeta padre)
     - Otros metadatos útiles (tamaño, dimensiones, etc.)
   - Tabla tags:
     - id (PK)
     - nombre_tag (único)
   - Tabla intermedia imagen_tags (muchos a muchos):
     - imagen_id (FK a imagenes)
     - tag_id (FK a tags)
   - Tabla proyectos (opcional, para vincular proyectos con imágenes):
     - id
     - nombre_proyecto
     - Otros metadatos del proyecto
   - Tabla intermedia proyecto_imagen (muchos a muchos):
     - proyecto_id
     - imagen_id

2. Elegir la tecnología para la BD:
   - Recomendación: SQLite (ligera, embebida, sin servidor, perfecta para escritorio).
   - Usar JDBC para conexión.

3. Crear capa de acceso a datos (DAO):
   - Clases Java que abstraen el acceso a la BD para:
     - Añadir/modificar/eliminar imágenes
     - Añadir/modificar/eliminar tags
     - Relacionar imágenes y tags
     - Consultas (búsquedas, filtros)

Fase 2: Población inicial y sincronización

1. Escaneo inicial del directorio raíz:
   - Leer todas las imágenes en disco (recursivo).
   - Insertar sus rutas y metadatos en la tabla imagenes si no existen.
   - Crear tags automáticos basados en la estructura de carpetas.
     - Ejemplo: si una imagen está en /figuras/cine/star wars/droides/, asignar tags: figuras, cine, star wars, droides.
   - Esto puede hacerse con un proceso batch o incremental.

2. Sincronización periódica:
   - Controlar si imágenes han sido añadidas, eliminadas o movidas.
   - Actualizar base de datos en consecuencia.
   - Marcar imágenes huérfanas (en BD pero no en disco) para revisión.

Fase 3: Sistema de Tags

1. Crear UI para gestión de tags:
   - Añadir tags individuales a una imagen.
   - Añadir tags masivos a selección de imágenes (desde modo Proyecto o desde modo Datos).
   - Eliminar tags de imágenes.

2. Tags en modo Proyecto:
   - Al seleccionar imágenes en proyecto, poder asignar un tag común a todas.
   - Esto ayudará a alimentar la BD sin procesar imagen por imagen.

3. Tags en modo Datos:
   - Sistema para filtrar imágenes por tags positivos y negativos.
   - Buscar imágenes sin tags (huérfanas).
   - Ordenar imágenes por tags (por ejemplo: mostrar primero imágenes con determinado tag).

4. Persistencia y consistencia:
   - Asegurar que cada cambio en tags se refleje inmediatamente en la BD.
   - Actualizar la UI en tiempo real.

Fase 4: Filtros y Búsquedas Avanzadas en Visualizador

1. Integración de filtros en visualizador:
   - Filtros positivos: solo imágenes con estos tags.
   - Filtros negativos: excluir imágenes con estos tags.
   - Combinación de filtros (AND, OR, NOT).

2. Mostrar resultados filtrados en lista de nombres y miniaturas.

3. Opciones de ordenación:
   - Por nombre, fecha, carpeta, o tags.

4. Visualización en modo datos:
   - Permitir previsualizar imágenes dentro del modo Datos (lista/miniaturas + imagen seleccionada).

Fase 5: Control y Gestión de Imágenes Huérfanas y Sin Tags

1. Detectar imágenes en BD que no existen en disco (huérfanas).
   - Mostrar alertas o listado para limpiar BD.

2. Detectar imágenes sin tags.
   - Mostrar para facilitar etiquetado.

3. Opciones para etiquetar rápido o eliminar registros huérfanos.

Fase 6: Movimiento y Reubicación de Archivos desde Modo Proyecto

1. UI para seleccionar imágenes y destino de carpeta:
   - Confirmación de movimiento masivo.
   - Posibilidad de crear subcarpetas destino automáticamente.

2. Actualizar en BD las rutas de las imágenes movidas.

3. Actualizar tags si la carpeta destino implica nuevos tags automáticos.

4. Mantener histórico (log) de movimientos.

Fase 7: Validación y Control de Acceso a Datos

1. No se requiere autentificación, pero sí:
   - Verificación de integridad en cada acceso a BD.
   - Manejo de excepciones si los datos no existen o están corruptos.

2. Sincronización con disco:
   - Validar que las rutas en BD coincidan con disco.

3. Opciones de reparación automática o manual.

Extras Recomendados

- Cache de consultas frecuentes para acelerar filtros y búsquedas.
- Indexación de tags en BD para consultas rápidas.
- Exportación/Importación de proyectos con sus tags.
- Interfaz para asignar múltiples tags a la vez con autocompletado.
- Vista previa rápida al pasar el cursor sobre tags o imágenes.

Resumen

| Paso | Qué Implementar | Impacto en otros modos |
|-------|-----------------|-----------------------|
| 1 | BD estructurada y DAO | Base de datos central |
| 2 | Escaneo inicial y sincronización | Población de datos, base para búsquedas |
| 3 | Gestión y asignación de tags | En proyecto y datos, alimenta filtros |
| 4 | Filtros en visualizador y modo datos | Navegación rápida y específica |
| 5 | Control huérfanos y sin tags | Limpieza y etiquetado |
| 6 | Movimiento archivos desde proyecto | Reubicación, actualización BD |
| 7 | Control acceso y validación | Robustez del sistema |


-------------------------------------------------------------------------
--- FIN DE LA HOJA DE RUTA PARA IMPLEMENTAR EL MODO DATOS ---
-------------------------------------------------------------------------



**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************


-------------------------------------------------------------------------
--- HOJA DE RUTA REVISADA PARA IMPLEMENTAR EL MODO DATOS (v2.1) ---
-------------------------------------------------------------------------

Basado en un enfoque pragmático y por fases para obtener valor rápidamente
y construir hacia una solución robusta y anti-frágil.

=========================================================================
--- FASE 1: NÚCLEO DE BÚSQUEDA Y FILTRADO INICIAL ---
=========================================================================
OBJETIVO: Tener una base de datos funcional que permita el filtrado básico
por tags en el Modo Visualizador. Esto proporciona el 80% del valor
buscado con el mínimo de complejidad inicial.

1.  DISEÑO INICIAL DE BASE DE DATOS (Simplificado y Temporal):
    - Se usará SQLite como motor de base de datos.
    - Se utilizará la RUTA COMPLETA del archivo como identificador único
      temporalmente. Somos conscientes de su fragilidad, pero permite un
      arranque rápido.

    - TABLA `images`:
        - id (INTEGER, PK, Autoincremental)
        - path (TEXT, UNIQUE): Ruta completa y absoluta al archivo.
        - filename (TEXT)
        - date_added (INTEGER): Timestamp de cuándo se añadió.

    - TABLA `tags`:
        - id (INTEGER, PK, Autoincremental)
        - name (TEXT, UNIQUE): El nombre de la etiqueta (ej: "skaven").

    - TABLA `image_tags` (Tabla de Unión):
        - image_id (INTEGER, FK a images.id)
        - tag_id (INTEGER, FK a tags.id)
        - PRIMARY KEY (image_id, tag_id)


2.  CREAR LA INFRAESTRUCTURA DE ACCESO A DATOS (DAO):
    - Clase `DatabaseManager.java` (en `servicios`):
        - Implementará el patrón Singleton.
        - Se encargará de la conexión con el archivo de la BBDD SQLite.
        - La ruta al archivo .db se definirá en `config.cfg`.
        - **Creación Automática:** Al arrancar, si el archivo .db no existe,
          el `DatabaseManager` lo creará automáticamente.
        - Método `init()`: Conecta y llama a la creación de tablas.
        - Método `createTablesIfNotExists()`: Ejecutará el SQL para crear
          las 3 tablas de la Fase 1 usando la sintaxis
          `CREATE TABLE IF NOT EXISTS ...`. Esto asegura que en un
          ordenador nuevo la BBDD se genere sola, y en uno existente no
          se produzcan errores.
    - Clase `DataAccessObject.java` (o similar, en `servicios.db`):
        - Utilizará JDBI para abstraer las consultas SQL.
        - Tendrá métodos como `addImage(path)`, `addTag(name)`,
          `linkTagToImage(imageId, tagId)`, `findImagesByTags([...])`.

3.  CREAR EL SERVICIO DE ESCANEO E INDEXACIÓN:
    - Clase `ScannerService.java` (en `servicios`):
        - Método `scanAndIndexFolder(Path rootFolder)`:
            - Recorrerá recursivamente la carpeta especificada.
            - Para cada imagen encontrada:
                1. La añadirá a la tabla `images` si su `path` no existe.
                2. Implementará el "Etiquetado Automático por Carpeta":
                   - Extraerá los nombres de las carpetas de la ruta
                     (ej: de "F:/figuras/juegos/bloodbowl", extraerá
                     "figuras", "juegos", "bloodbowl").
                   - Añadirá cada nombre de carpeta como un tag en la tabla
                     `tags` si no existe.
                   - Vinculará estos tags a la imagen en la tabla `image_tags`.

4.  INTEGRAR LA BÚSQUEDA EN LA LÓGICA DE LA APLICACIÓN:
    - Modificar `FilterManager.java`:
        - Añadir un nuevo tipo de filtro: `FilterType.DATABASE_TAGS`.
        - Cuando se aplique este filtro, en lugar de operar sobre la
          lista en memoria, llamará al `DataAccessObject` para obtener
          la lista de rutas de imágenes que coincidan con los tags.
    - Modificar `VisorController.java` y `GeneralController.java`:
        - El resultado de la búsqueda en la BBDD (la lista de rutas) se
          cargará en el `VisorModel` como la nueva "lista maestra" a visualizar.

---
RESULTADO ESPERADO DE LA FASE 1: El usuario puede indexar una carpeta.
Después, puede usar un campo de búsqueda en la UI para filtrar las
26,000 imágenes por los tags generados automáticamente, viendo los
resultados al instante en el visualizador. La aplicación es portable a
un nuevo PC, donde creará la BBDD vacía al primer arranque.

=========================================================================
--- FASE 2: ETIQUETADO MANUAL Y SINCRONIZACIÓN ---
=========================================================================
OBJETIVO: Dar al usuario el poder de curar y enriquecer los datos de la
base de datos, y mantenerla actualizada con los cambios en el disco.

1.  IMPLEMENTAR LA INTERFAZ DE ETIQUETADO:
    - En la UI del Modo Visualizador/Datos, añadir:
        - Un área para mostrar los tags de la imagen seleccionada.
        - Un campo de texto para añadir nuevos tags.
        - Un botón para eliminar tags existentes de una imagen.
    - Implementar el "Etiquetado en Bloque" desde el Modo Proyecto:
        - Añadir una acción/botón en el Modo Proyecto.
        - Al pulsarlo, un diálogo permitirá introducir uno o más tags que
          se aplicarán a TODAS las imágenes actualmente en la lista de
          selección del proyecto.

2.  IMPLEMENTAR UN GESTOR DE TAGS CENTRALIZADO (Modo Datos):
    - Crear una nueva vista/panel para la gestión global de tags.
    - Funcionalidades:
        - Ver todas las etiquetas existentes en la BBDD.
        - Renombrar un tag (se actualizará en todas las imágenes).
        - Eliminar un tag (se desvinculará de todas las imágenes).
        - Fusionar tags (ej: "skavens" y "skaven" en uno solo).

3.  CREAR UN SERVICIO DE SINCRONIZACIÓN BÁSICO:
    - Añadir una acción "Sincronizar Discos" en el menú.
    - Al ejecutarla, el `ScannerService` volverá a recorrer las carpetas
      raíz configuradas.
    - Lógica:
        - Detectará archivos nuevos y los añadirá a la BBDD.
        - Detectará archivos que estaban en la BBDD pero ya no están en
          el disco, marcándolos como "huérfanos" (con un flag en la
          tabla `images`).

---
RESULTADO ESPERADO DE LA FASE 2: El usuario puede corregir y ampliar
el etiquetado automático, mejorando drásticamente la calidad de los
resultados de búsqueda. La base de datos se mantiene razonablemente
actualizada con el sistema de archivos.

=========================================================================
--- FASE 3: MIGRACIÓN AL SISTEMA ANTI-FRÁGIL (HASHES) ---
=========================================================================
OBJETIVO: Hacer que la base de datos sea resiliente a movimientos,
renombres de archivos y cambios en la estructura de carpetas, y manejar
correctamente las complejas asociaciones entre imágenes y archivos de modelo.

1.  MIGRACIÓN DEL ESQUEMA DE LA BASE DE DATOS:
    - Añadir las nuevas tablas al `DatabaseManager`: `resources`, `locations`,
      y `resource_associations`.
    - Crear un script de migración (un método en `DatabaseManager`) que:
        - Lea todos los datos de la antigua tabla `images`.
        - Para cada imagen, calcule su HASH.
        - Cree una entrada en la tabla `resources` con el hash.
        - Cree una entrada en la tabla `locations` con la ruta.
        - Migre las relaciones de tags a la nueva tabla `resource_tags`.
        - Finalmente, eliminar la antigua tabla `images`.

2.  REFACTORIZAR LA LÓGICA DE LA APLICACIÓN:
    - El `ScannerService` ahora calculará hashes y poblará las tablas
      `resources` y `locations`. Su lógica de "sincronización" será más
      compleja: detectará archivos movidos (mismo hash, nueva location).
    - Todas las consultas del `DataAccessObject` y del `FilterManager`
      ahora se basarán en los `resource_id` en lugar de en los `path`.
      El `path` se obtendrá de la tabla `locations` solo al final, para
      mostrar la imagen.

3.  IMPLEMENTAR LA ASOCIACIÓN IMAGEN-ARCHIVO:
    - Añadir lógica en el `ScannerService` para identificar no solo
      imágenes, sino también archivos (`.zip`, `.rar`, `.stl`...).
    - Estos también se añadirán como entradas en la tabla `resources`.
    - Lógica de asociación (heurística inicial):
        - Si una imagen (`img.png`) y un zip (`img.zip`) están en la
          misma carpeta y comparten el mismo nombre base, crear una
          entrada en `resource_associations`.
    - Añadir una interfaz en el Modo Proyecto para que el usuario pueda
      corregir o crear estas asociaciones manualmente.

---
RESULTADO ESPERADO DE LA FASE 3: La aplicación se vuelve extremadamente
robusta. El usuario puede reorganizar sus discos duros sin miedo a
perder todo el trabajo de etiquetado. La función "Búsqueda y Rescate"
ahora funciona a la perfección, encontrando los zips/stls asociados a
una imagen sin importar dónde estén.

-------------------------------------------------------------------------
--- FIN DE LA HOJA DE RUTA PARA IMPLEMENTAR EL MODO DATOS 2.1 ---
-------------------------------------------------------------------------



**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************



=========================================================
 HOJA DE RUTA - VISOR DE IMÁGENES V2
=========================================================

FASE 1: REFINAMIENTO DE NAVEGACIÓN Y UX FUNDAMENTALES
---------------------------------------------------------

[v] 1.1: Integrar Zoom Inteligente (SMART_FIT) en la UI
    - [v] Crear la Action correspondiente en ActionFactory (AplicarModoZoomAction para SMART_FIT).
    - [v] Añadir la constante CMD_ZOOM_TIPO_SMART_FIT en AppActionCommands.
    - [v] Añadir el botón a la barra de herramientas "zoom" en UIDefinitionService.
    - [v] Añadir el JRadioButtonMenuItem al menú "Zoom".
    - [v] Confirmar que es el modo por defecto al iniciar la aplicación.

[v] 1.2: Paneo Rápido con Atajos de Teclado (Ctrl + Alt)
    - [v] Modificar GeneralController (KeyEventDispatcher) para detectar la pulsación y liberación de Ctrl+Alt.
    - [v] Añadir un flag (ej. `isPanHotkeyPressed`) en GeneralController.
    - [v] Modificar los listeners de `mouseDragged` para que activen el paneo si `isZoomHabilitado()` O `isPanHotkeyPressed` es true.
    - [v] Implementar la lógica para cambiar el cursor del ratón a una mano (Cursor.HAND_CURSOR) cuando las teclas están presionadas.

[ ] 1.3: Navegación Fluida con Carga Retardada (Debounced Loading)
    - [ ] En GeneralController (o donde se gestione la rueda del ratón), en lugar de llamar a `navegarSiguiente/Anterior` directamente, reiniciar un `javax.swing.Timer`.
    - [ ] Cuando el Timer se dispare (el usuario ha parado), ejecutar la lógica de cambio de imagen.
    - [ ] (Opcional) Mostrar un "placeholder" o simplemente no hacer nada visualmente mientras la rueda se mueve rápido.

[v] 1.4: Persistencia de la Última Imagen Vista
    - [v] En `VisorController.guardarConfiguracionActual()`, asegurarse de guardar `model.getSelectedImageKey()` en una clave de config (ej. `inicio.imagen`).
    - [v] En `AppInitializer`, al cargar la configuración, leer esta clave.
    - [v] Pasar esta clave a `visorController.cargarListaImagenes()` para que la seleccione al iniciar.

[ ] 1.5: Salto Rápido entre Carpetas (Folder Skipping)
    - [ ] Crear nuevas Actions en ActionFactory (ej. `NextFolderAction`, `PreviousFolderAction`).
    - [ ] Implementar la lógica (posiblemente en una nueva clase `FolderNavigationService`) que, dada la carpeta actual, encuentre la siguiente/anterior carpeta hermana.
    - [ ] El `VisorController` llamará a este servicio y luego a `cargarListaImagenes` con la nueva ruta.
    - [ ] Añadir botones y atajos para estas nuevas acciones.

[ ] 1.6: Ajuste Dinámico del Tamaño de Miniaturas
    - [ ] Crear Actions `IncreaseThumbnailSizeAction` y `DecreaseThumbnailSizeAction`.
    - [ ] Estas acciones modificarán valores en `ConfigurationManager` (ej. `miniaturas.tamano.normal.ancho`).
    - [ ] El `ListCoordinator` o `VisorController`, al detectar este cambio, debe forzar una recreación del `MiniaturaListCellRenderer` y un `revalidate/repaint` de la `JList` de miniaturas.

[ ] 1.7: Vista de Árbol de Carpetas (Folder Tree)
    - [v] Crear una vista alternativa para el panel izquierdo que contenga un `JTree`.
    - [v] Implementar un `TreeModel` personalizado que cargue los directorios de forma perezosa (lazy loading) para un buen rendimiento.
    - [v] Añadir un `TreeSelectionListener` que actualice la carpeta raíz del `VisorModel` y recargue las imágenes cuando se selecciona una nueva carpeta.
    - [v] Añadir una Action para cambiar entre la vista de lista de archivos y la vista de árbol.


FASE 2: IMPLEMENTACIÓN DE NUEVOS MODOS DE VISUALIZACIÓN (DisplayMode)
-------------------------------------------------------------------------

[ ] 2.1: Implementar DisplayMode.GRID (Vista de Cuadrícula)
    - [v] Crear la clase `GridDisplayPanel.java` (usando `JList` con `HORIZONTAL_WRAP` y `JScrollPane`).
    - [v] Crear `GridCellRenderer.java`, un `ListCellRenderer` que dibuje una miniatura con su nombre debajo. Debe usar la lógica SMART_FIT para escalar la miniatura dentro de la celda.
    - [v] Crear nuevas Actions `GridZoomInAction` y `GridZoomOutAction` que llamen a métodos en `GridDisplayPanel` para cambiar el número de columnas/tamaño de celda.
    - [ ] Añadir una barra de herramientas inferior al `GridDisplayPanel` para estos nuevos controles.
    - [ ] Habilitar la selección múltiple en la `JList` interna.
    - [v] Adaptar las acciones (ej. "Marcar") para que operen sobre todos los elementos seleccionados en el grid.

[ ] 2.2: Implementar DisplayMode.CAROUSEL (Carrusel/Filmstrip)
    - [v] Crear la clase `CarouselDisplayPanel.java`.
    - [v] El panel tendrá un `ImageDisplayPanel` grande en el centro y un `JScrollPane` horizontal (la tira) en la parte inferior.
    - [v] La tira de miniaturas puede ser una `JList` en modo `HORIZONTAL_WRAP` con una sola fila de alto (`setVisibleRowCount(1)`).
    - [v] Implementar la lógica de sincronización: al cambiar la imagen principal, la `JList` de la tira hace `ensureIndexIsVisible`. Al hacer clic en la tira, se cambia la imagen principal.

[ ] 2.3: Implementar DisplayMode.POLAROID
    - [ ] Crear la clase `PolaroidDisplayPanel.java`.
    - [ ] Sobrescribir `paintComponent` para dibujar un rectángulo blanco de fondo.
    - [ ] Usar `AffineTransform` para aplicar una rotación ligera (`g2d.rotate(...)`) antes de dibujar la imagen.


FASE 3: AJUSTES DE COMPORTAMIENTO POR CONTEXTO (WorkMode)
----------------------------------------------------------------

[ ] 3.1: Habilitar/Deshabilitar Actions según el Modo
    - [ ] Modificar el método `updateEnabledState` de todas las `ContextSensitiveAction` para que consideren el `WorkMode` y `DisplayMode` actuales.
    - [ ] Por ejemplo, las acciones de paneo y zoom de imagen única deben deshabilitarse cuando el `DisplayMode` es `GRID`.
    - [ ] La acción "Marcar Imagen" debe cambiar su lógica: en modo `PROYECTO`, mueve a descartes/selección; en modo `VISUALIZADOR`, añade al proyecto temporal.

[ ] 3.2: Adaptar el Selector de Archivo/Carpeta
    - [ ] La acción `OpenFileAction` debe comprobar el `WorkMode` actual.
    - [ ] Si es `VISUALIZADOR`, abre un `JFileChooser` para seleccionar directorios.
    - [ ] Si es `PROYECTO`, abre un `JFileChooser` para seleccionar archivos de proyecto (ej. `.visprj`).
    
    
    

**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************
    
    
/*
************************************
* MEGACOMENTARIO PARAA CARGA Y ORDEN
************************************


¡Excelente decisión! La disciplina ahora te ahorrará dolores de cabeza después.

Aquí tienes un prompt detallado que resume lo que hemos discutido sobre la refactorización de la funcionalidad de "Carga y Orden", moviendo la configuración por defecto al menú "Configuración" y añadiendo una barra de herramientas para la ordenación temporal. Puedes usar esto como tu hoja de ruta cuando retomes esta parte.

---

**Prompt para la Refactorización de la Funcionalidad de "Carga y Orden"**

**Objetivo General:**
Separar la configuración de la ordenación *por defecto* (persistente) de la capacidad de aplicar una ordenación *temporal* a la vista actual. Mejorar la usabilidad proporcionando acceso rápido a la ordenación temporal mediante una nueva sección en la barra de herramientas y simplificando los menús.

**Fases y Tareas Detalladas:**

**FASE 1: Definición de Comandos y Estados en el Modelo**

1.  **`controlador.commands.AppActionCommands.java`:**
    *   **Definir/Verificar Comandos para Ordenación por Defecto (Configuración):**
        *   `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_NOMBRE` (ej: "cmd.config.orden.default.crit.nombre")
        *   `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_TAMANO`
        *   `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_FECHA`
        *   `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_EXTENSION`
        *   `CMD_CONFIG_ORDEN_DEFAULT_DIRECCION_ASC`
        *   `CMD_CONFIG_ORDEN_DEFAULT_DIRECCION_DESC`
        *   `CMD_CONFIG_ORDEN_DEFAULT_DIRECCION_NINGUNO` (si se mantiene "Sin Ordenar" como opción default)
    *   **Definir/Verificar Comandos para Ordenación Temporal (Toolbar/Acción Rápida):**
        *   `CMD_ORDEN_TEMP_SET_CRITERIO_NOMBRE` (ej: "cmd.orden.temp.crit.nombre")
        *   `CMD_ORDEN_TEMP_SET_CRITERIO_TAMANO`
        *   `CMD_ORDEN_TEMP_SET_CRITERIO_FECHA`
        *   `CMD_ORDEN_TEMP_SET_CRITERIO_EXTENSION`
        *   `CMD_ORDEN_TEMP_TOGGLE_DIRECCION` (para un botón que cicle Asc/Desc) O:
        *   `CMD_ORDEN_TEMP_SET_DIRECCION_ASC`
        *   `CMD_ORDEN_TEMP_SET_DIRECCION_DESC`
        *   `CMD_ORDEN_TEMP_SET_DIRECCION_NINGUNO` (si se mantiene "Sin Ordenar" como opción temporal)

2.  **`modelo.VisorModel.java`:**
    *   **Añadir Enums para Criterio y Dirección (si no existen):**
        ```java
        public enum CriterioOrdenacion { NOMBRE, TAMANO, FECHA, EXTENSION, NINGUNO }
        public enum DireccionOrdenacion { ASCENDENTE, DESCENDENTE, NINGUNO } // 'NINGUNO' para dirección puede ser implícito si el criterio es NINGUNO
        ```
    *   **Campos para Configuración de Ordenación por Defecto:**
        *   `private CriterioOrdenacion criterioOrdenacionDefault = CriterioOrdenacion.NOMBRE;`
        *   `private DireccionOrdenacion direccionOrdenacionDefault = DireccionOrdenacion.ASCENDENTE;`
        *   Getters y Setters (los setters serán llamados por las Actions de Configuración).
        *   Estos campos se inicializarán desde `ConfigurationManager` al arrancar la aplicación.
    *   **Campos para Ordenación Temporal de la Vista Actual:**
        *   `private CriterioOrdenacion criterioOrdenacionTemporal;`
        *   `private DireccionOrdenacion direccionOrdenacionTemporal;`
        *   Getters y Setters (los setters serán llamados por las Actions de la Toolbar).
        *   Al cargar una nueva carpeta, estos campos temporales se resetean a los valores `...Default` o a un estado "sin ordenación temporal activa".

**FASE 2: Definición de la Interfaz de Usuario (`UIDefinitionService.java`)**

1.  **Menú "Imagen":**
    *   **Eliminar** el submenú "Carga y Orden" y todos sus ítems.

2.  **Menú "Configuración" -> Submenú "Carga y Ordenación" (o similar):**
    *   Este submenú ahora contendrá las opciones para establecer los **defaults persistentes**.
    *   **Sub-Submenú "Criterio de Ordenación Predeterminado":**
        *   Grupo de `JRadioButtonMenuItem`s vinculados a `CMD_CONFIG_ORDEN_DEFAULT_CRITERIO_...`.
        *   Textos: "Nombre", "Tamaño", "Fecha", "Extensión".
    *   **Sub-Submenú "Dirección de Ordenación Predeterminada":**
        *   Grupo de `JRadioButtonMenuItem`s vinculados a `CMD_CONFIG_ORDEN_DEFAULT_DIRECCION_...`.
        *   Textos: "Ascendente", "Descendente", "Sin Ordenar" (opcional).

3.  **Barra de Herramientas (Nueva Sección "Ordenación"):**
    *   **Botón/Control para Criterio de Ordenación Temporal:**
        *   **Opción A (Botón con `JPopupMenu`):**
            *   `ToolbarButtonDefinition` para un `JButton` principal (ej. `CMD_ORDEN_TEMP_MOSTRAR_CRITERIOS`, texto "Ordenar Por:", icono genérico de orden).
            *   El `JPopupMenu` se construiría dinámicamente en `ToolbarBuilder` o se asociaría en `VisorController`, conteniendo ítems para "Nombre", "Tamaño", etc., cada uno vinculado a su `CMD_ORDEN_TEMP_SET_CRITERIO_...`.
        *   **Opción B (`JComboBox`):**
            *   No se define directamente como `ToolbarButtonDefinition`. `ToolbarBuilder` crearía un `JComboBox` y lo poblaría. Se necesitaría un `ActionListener` o `ItemListener` para él.
    *   **Botón/Control para Dirección de Ordenación Temporal:**
        *   **Opción A (Botón Cíclico `JButton`):**
            *   `ToolbarButtonDefinition` para un `JButton` (ej. `CMD_ORDEN_TEMP_TOGGLE_DIRECCION`). Icono y texto cambiarán según el estado (A-Z, Z-A, ---).
        *   **Opción B (Grupo de `JToggleButton`):**
            *   Dos o tres `ToolbarButtonDefinition` para `JToggleButton`s (ej. `CMD_ORDEN_TEMP_SET_DIRECCION_ASC`, `CMD_ORDEN_TEMP_SET_DIRECCION_DESC`), agrupados visualmente y en un `ButtonGroup`.

**FASE 3: Implementación de Actions (`ActionFactory.java`)**

1.  **Actions para Configuración de Orden por Defecto:**
    *   Clase: `SetOrdenDefaultAction` (o nombres más específicos como `SetCriterioOrdenDefaultAction`, `SetDireccionOrdenDefaultAction`).
    *   Constructor: Recibe `ConfigurationManager`, el criterio/dirección que representa, y la clave de config a modificar.
    *   `actionPerformed()`: Llama a `configuration.setString("clave.default.criterio", "valor_criterio")` y `configuration.setString("clave.default.direccion", "valor_direccion")`. Actualiza el estado `.seleccionado` de los radios en su grupo.
    *   Estas `Action`s se asignarán a los `JRadioButtonMenuItem` del menú "Configuración".

2.  **Actions para Ordenación Temporal (Toolbar):**
    *   **Para Criterio:**
        *   Si es `JPopupMenu`: Cada `JMenuItem` del popup necesita una `Action` (ej. `AplicarCriterioOrdenTemporalAction`) que tome el criterio como parámetro.
        *   `actionPerformed()`: Llama a `model.setCriterioOrdenacionTemporal(nuevoCriterio)`, actualiza el texto/icono del botón principal de la toolbar, y dispara la reordenación (`controller.solicitarReordenacionVistaActual()`).
    *   **Para Dirección:**
        *   Si es botón cíclico: Una `Action` (`ToggleDireccionOrdenTemporalAction`).
            *   `actionPerformed()`: Ciclac `model.getDireccionOrdenacionTemporal()`, actualiza el icono/texto del botón, y dispara la reordenación.
        *   Si son `JToggleButton`s: `Action`s individuales (`SetDireccionAscTemporalAction`, `SetDireccionDescTemporalAction`).
            *   `actionPerformed()`: Establece `model.setDireccionOrdenacionTemporal(...)`, actualiza `Action.SELECTED_KEY`, y dispara reordenación.

**FASE 4: Lógica en Controladores y Servicios**

1.  **`VisorController.java`:**
    *   **`cargarListaImagenes(String claveImagenAMantener)`:**
        *   Al inicio, obtener `criterioActivo` y `direccionActiva`:
            *   Si `model.getCriterioOrdenacionTemporal()` no es "ninguno" o `null`, usar los valores temporales.
            *   Si no, usar `model.getCriterioOrdenacionDefault()` y `model.getDireccionOrdenacionDefault()`.
        *   Usar `criterioActivo` y `direccionActiva` para ordenar `clavesOrdenadas` (o el `mapaResultado`) ANTES de crear el `DefaultListModel` para `listaNombres`. Esto requerirá un `Comparator` personalizado.
    *   **`solicitarReordenacionVistaActual()` (Nuevo método):**
        *   Llamado por las `Action`s de ordenación temporal.
        *   Obtiene la `claveImagenAMantener` del `model.getSelectedImageKey()`.
        *   Llama a `cargarListaImagenes(claveImagenAMantener)` para forzar una recarga y reordenación con los nuevos criterios temporales.
        *   Actualiza la UI de la toolbar de ordenación para reflejar el estado actual.

2.  **`ConfigurationManager.java`:**
    *   **`DEFAULT_CONFIG`:** Añadir las nuevas claves para la ordenación por defecto:
        *   `comportamiento.orden.default.criterio = NOMBRE` (o el que prefieras)
        *   `comportamiento.orden.default.direccion = ASCENDENTE`
        *   Claves `.seleccionado` para los `JRadioButtonMenuItem` del menú "Configuración" que controlan estos defaults.
    *   **`createDefaultGroupCommentsMap()`:** Añadir comentarios para estas nuevas secciones/claves.
    *   **`guardarConfiguracionActual()` en `VisorController`:** Debe asegurar que los valores de `model.getCriterioOrdenacionDefault()` y `model.getDireccionOrdenacionDefault()` se escriban en `estadoFinalAGuardar` con las claves correctas (esto podría hacerse obteniéndolos de las `Action`s de configuración si estas actualizan `this.configuration`, o directamente del modelo si las `Action`s solo actualizan el modelo y el `config.cfg`).

3.  **`MenuBarBuilder.java` y `ToolbarBuilder.java`:**
    *   Adaptarlos para construir los nuevos ítems de menú y los componentes de la toolbar de ordenación, asignando las `Action`s correctas.
    *   `ToolbarBuilder` podría necesitar lógica especial para el botón de criterio con `JPopupMenu` o para los `JToggleButton` agrupados.

4.  **`AppInitializer.java`:**
    *   En `aplicarConfiguracionAlModelo()`: Leer `comportamiento.orden.default.criterio` y `comportamiento.orden.default.direccion` de `configuration` y establecerlos en `model.setCriterioOrdenacionDefault()` y `model.setDireccionOrdenacionDefault()`.
    *   En `aplicarConfigAlaVistaInternal()`: Asegurar que los `JRadioButtonMenuItem` del menú "Configuración" para la ordenación por defecto reflejen el estado cargado.

**FASE 5: Sincronización Visual**

*   Cuando se cambia un criterio o dirección de ordenación temporal (desde la toolbar), los botones de la toolbar deben actualizar su apariencia.
*   Cuando se cambia un criterio o dirección de ordenación por defecto (desde el menú Configuración), los `JRadioButtonMenuItem` de ese menú deben actualizar su estado seleccionado. (Las `Action`s deberían manejar esto con `Action.SELECTED_KEY` y `ButtonGroup`).

---

Este prompt es bastante exhaustivo, pero cubre los cambios necesarios en las diferentes capas de tu aplicación para implementar la funcionalidad de ordenación de forma clara y separada para la configuración persistente y la manipulación temporal.

Cuando estés listo, puedes ir abordando cada fase. ¡No dudes en preguntar si algo no está claro o si necesitas ayuda con una parte específica!

  
*/    




**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************


HOJA DE RUTA: IMPLEMENTACIÓN DEL MODO DE VISUALIZACIÓN GRID

Versión: 1.0
Fecha: 23/05/2024
Proyecto: Visor/Catalogador de Imágenes

======================================================================
== OBJETIVO GENERAL
======================================================================
Implementar un modo de visualización "Grid" (cuadrícula) completamente funcional y reutilizable, que permita al usuario ver múltiples imágenes a la vez, realizar selecciones múltiples y sirva como base para futuras operaciones por lotes. La implementación debe integrarse de forma nativa en la arquitectura existente (MVC, Managers, ComponentRegistry, Model-driven UI).

======================================================================
== FASE 1: CONSTRUCCIÓN DE LOS COMPONENTES DE LA VISTA (UI)
======================================================================

1.1. Creación del Panel de Visualización del Grid:
    - Nombre del archivo: `vista/panels/GridDisplayPanel.java`
    - Heredará de: `JPanel` con `BorderLayout`.
    - Componente principal interno: `JList<String>` configurado para actuar como un grid (`setLayoutOrientation(JList.HORIZONTAL_WRAP)` y `setVisibleRowCount(-1)`).
    - El `JList` estará contenido en un `JScrollPane`.
    - Responsabilidades:
        - Mostrar una cuadrícula de celdas.
        - Ser "tonto" en cuanto a datos: recibe una lista de claves de imagen y la muestra.
        - Exponer su `JList` interna a través de un método `getGridList()` para que los controladores puedan interactuar con ella.

1.2. Creación del Renderer de Celdas del Grid:
    - Nombre del archivo: `vista/renderers/GridCellRenderer.java`
    - Heredará de: `JPanel` e implementará `ListCellRenderer<String>`.
    - Se basará en el diseño y la lógica de `MiniaturaListCellRenderer.java`.
    - Responsabilidades:
        - Dibujar una única celda del grid.
        - Mostrar una miniatura de un tamaño predefinido (ej. 128x128).
        - Obtener la miniatura a través del `ThumbnailService` existente. Se decidirá si estas miniaturas más grandes se cachean o no (propuesta inicial: no cachear para proteger el LruCache, confiando en la velocidad del escalado).
        - Mostrar el nombre del archivo debajo de la miniatura, con gestión de saltos de línea para nombres largos (usando HTML).
        - Gestionar la apariencia visual de la selección (color de fondo, borde).

1.3. Integración en `ViewBuilder.java`:
    - Localizar el método `createRightSplitComponent()`.
    - Reemplazar el `JPanel` placeholder de "VISTA_GRID" por una instancia real de `new GridDisplayPanel(...)`.
    - Registrar el nuevo panel en `ComponentRegistry` con la clave `"panel.display.grid"`.
    - Registrar la `JList` interna del panel en `ComponentRegistry` con la clave `"list.grid"`.

======================================================================
== FASE 2: LÓGICA DE CONTROL Y SINCRONIZACIÓN
======================================================================

2.1. Orquestación del Cambio de Modo (en `GeneralController` o similar):
    - Se creará un método (ej. `switchToDisplayMode(DisplayMode newMode)`) que centralice la lógica.
    - Responsabilidades de este método al cambiar a MODO_GRID:
        a. Poblar el Grid: Obtener la lista de claves de imagen del `VisorModel` (`model.getCurrentListContext().getModeloLista()`) y pasarla al `GridDisplayPanel` (`gridDisplayPanel.setImageKeys(...)`).
        b. Cambiar la Vista: Llamar a `viewManager.cambiarAVista("container.displaymodes", "VISTA_GRID")`.
        c. Sincronizar Selección: Obtener el índice actual del `VisorModel` (`model.getIndiceActual()`) y usarlo para seleccionar y hacer visible el elemento correspondiente en el `GridDisplayPanel`.
        d. Gestionar Visibilidad de Paneles (Lógica Inteligente):
            - Ocultar automáticamente la barra de miniaturas inferior (`scroll.miniaturas`) llamando al `ViewManager`.
            - Actualizar el estado del `JCheckBoxMenuItem` de "Mostrar Miniaturas" en el menú para que aparezca desmarcado.
            - Guardar el nuevo estado de visibilidad de las miniaturas en el archivo `config.cfg`.
        e. Persistir el Modo: Guardar el nuevo modo de visualización en `config.cfg` (ej. `ui.displaymode.lastUsed = "GRID"`).

2.2. Interacción del Usuario con el Grid:
    - Se añadirá un `ListSelectionListener` a la `JList` del `GridDisplayPanel`.
    - Evento de Clic Simple/Selección:
        - El listener notificará al `ListCoordinator` del nuevo índice seleccionado (`listCoordinator.seleccionarImagenPorIndice(newIndex)`).
        - El `ListCoordinator` se encargará de actualizar el modelo y sincronizar las otras vistas (si estuvieran visibles), como la lista de nombres.
    - Evento de Doble Clic:
        - Se añadirá un `MouseListener` a la `JList`.
        - Al detectar un doble clic, se cambiará de vuelta al modo de imagen única (`switchToDisplayMode(DisplayMode.SINGLE_IMAGE)`), mostrando la imagen en la que se hizo clic.

2.3. Sincronización Inversa (del `ListCoordinator` al `Grid`):
    - Se modificará el `ListCoordinator` (o un método que lo use) para que, además de sincronizar las listas existentes, también sincronice la selección en el grid si este está visible.
    - `listCoordinator.seleccionarImagenPorIndice()` llamará, indirectamente, a `sincronizarSeleccionJList(registry.get("list.grid"), index)`.

======================================================================
== FASE 3: FUNCIONALIDADES AVANZADAS Y REQUISITOS ESPECÍFICOS
======================================================================

3.1. Selección Múltiple (Estilo Explorador de Windows):
    - Se configurará la `JList` del `GridDisplayPanel` con `setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION)`.
    - Se aplicará la misma configuración a la `JList` de la lista de nombres (`list.nombresArchivo`) para añadir esta funcionalidad también en la vista principal.

3.2. Adaptación de Acciones para Procesamiento por Lotes:
    - Las acciones existentes (ej. "Marcar", "Descartar", "Exportar") deberán ser modificadas.
    - Su lógica deberá comprobar el modo de visualización actual.
    - Si el modo es `GRID`, la acción deberá operar sobre la lista de elementos seleccionados (`gridList.getSelectedValuesList()`) en lugar de sobre el único índice del modelo.

3.3. Barra de Herramientas Específica para el Grid (Post-implementación inicial):
    - Se diseñará y añadirá un `JToolBar` en la zona sur del `GridDisplayPanel`.
    - Contendrá controles para:
        - Aumentar/reducir el tamaño de las celdas (zoom del grid).
        - Navegación por páginas (siguiente/anterior), utilizando el valor de `salto de bloque` ya existente en la configuración.

3.4. Previsualización con Doble Clic (Post-implementación inicial):
    - En lugar de cambiar de modo, se podría implementar que el doble clic abra un `JDialog` modal.
    - Este diálogo contendría una instancia de `ImageDisplayPanel` para mostrar la imagen en un tamaño mayor, permitiendo zoom y paneo sin salir del modo Grid. Esta es una alternativa al punto 2.2.

======================================================================
== FIN DEL INFORME
======================================================================


**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************



============================================================
CLASES INVOLUCRADAS EN EL SISTEMA DE LA BARRA DE MINIATURAS
============================================================

--- Capa de la Vista (El "Cómo se ve") ---

1. vista.builders.ViewBuilder
   Funcion: Es el "arquitecto". Construye la JList y el JScrollPane de la barra de miniaturas y le asigna el MiniaturaListCellRenderer.

2. vista.renderers.MiniaturaListCellRenderer
   Funcion: Es el "pintor". Se encarga de dibujar cada celda individual de la lista, solicitando la imagen al ThumbnailService y aplicando los colores y bordes del tema actual.


--- Capa del Controlador (La "Lógica") ---

3. controlador.ListCoordinator
   Funcion: Es el "director de orquesta". Gestiona la lógica del "viewport" (qué miniaturas mostrar) y mantiene sincronizadas la selección en la lista de nombres, la barra de miniaturas y la imagen principal.

4. controlador.VisorController
   Funcion: Es el "controlador general". Inicia la carga de la lista de imágenes y sirve de nexo entre la vista, el modelo y los coordinadores/servicios.


--- Capa del Modelo (Los "Datos") ---

5. modelo.VisorModel
   Funcion: Es la "fuente de la verdad". Contiene la lista maestra completa con las rutas de todas las imágenes y el estado de la selección actual.


--- Capa de Servicios (Los "Trabajadores") ---

6. servicios.image.ThumbnailService
   Funcion: Es la "fábrica de miniaturas". Carga las imágenes desde el disco, las redimensiona al tamaño correcto y las guarda en un caché para un acceso rápido.

7. servicios.cache.LruCache
   Funcion: Es el "gestor de memoria" del ThumbnailService. Implementa el caché que almacena las miniaturas, descartando automáticamente las más antiguas para evitar un consumo excesivo de memoria.
   
**********************************************************************************************************************************************   
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************

**********************************************************************************************************************************************
														FASES PREVIAS AL MODO DATOS
**********************************************************************************************************************************************


-------------------------------------------------------------------------
--- HOJA DE RUTA: EVOLUCIÓN DEL MODO PROYECTO Y FUTURO MODO DATOS ---
-------------------------------------------------------------------------

== OBJETIVO GENERAL ==
Evolucionar la aplicación desde un sistema de proyectos basado en archivos de texto
hacia un sistema robusto, con persistencia de datos estructurada, para finalmente
implementar un potente catalogador de imágenes basado en una base de datos.


=========================================================================
--- TRACK A: FORTALECER EL MODO PROYECTO (PRIORIDAD ACTUAL) ---
=========================================================================
Objetivo: Transformar el Modo Proyecto en una herramienta de curación y
exportación profesional, donde el trabajo del usuario (selección de imágenes,
asignación de archivos asociados) se guarde de forma persistente.

---
--- FASE A.1: ESTRUCTURAR DATOS DEL PROYECTO (Modelo y Persistencia) ---
---
   - ESTADO: [COMPLETADO]

   - TAREAS REALIZADAS:
     1. [HECHO] Creación del `ProjectModel.java`: Se ha creado un objeto Java
        (POJO) que representa la estructura completa de un proyecto (nombre,
        fechas, listas de selección y descartes, y un campo para futuros
        archivos asociados).

     2. [HECHO] Transición de TXT a JSON: Se ha refactorizado el `ProjectManager`
        para utilizar la librería GSON. Ahora los proyectos se guardan y
        cargan en formato JSON, que es estructurado, robusto y extensible.

     3. [HECHO] Migración Automática: Se ha implementado una lógica en el
        `ProjectManager` que detecta proyectos en el formato antiguo (.txt)
        y los convierte automáticamente al nuevo formato JSON (.prj) la
        primera vez que se abren. Esto garantiza la retrocompatibilidad.

     4. [HECHO] Corrección de Bugs de Flujo: Se han solucionado los problemas
        que surgieron durante la refactorización, como el fallo al cambiar
        de modo y, crucialmente, el bug que provocaba que los archivos de
        proyecto se guardaran vacíos. Ahora el estado de la UI se sincroniza
        con el modelo de datos antes de guardar.

---
--- FASE A.2: PERSISTIR EL TRABAJO DE EXPORTACIÓN (PRÓXIMO PASO) ---
---
   - ESTADO: [COMPLETADO]

   - OBJETIVO: Guardar en el archivo del proyecto (.prj) las asociaciones
     que el usuario realiza en el panel de exportación entre una imagen y
     sus archivos relacionados (.stl, .zip, etc.). Esto evita tener que
     reasignar estos archivos cada vez que se abre el proyecto.

   - TAREAS A REALIZAR:
     1. [HECHO] Extender `ProjectController`: Añadir lógica para que, cuando
        se asigna/desasigna un archivo en el `ExportDetailPanel`, el cambio
        se comunique al `ProjectManager`.

     2. [HECHO] Modificar `ProjectManager`: Implementar métodos para añadir/eliminar
        entradas en el mapa `associatedFiles` del `ProjectModel` y guardar
        los cambios en el archivo JSON.

     3. [HECHO] Integrar con `ExportQueueManager`: Al preparar la cola de
        exportación, se deberá leer el `ProjectModel` para pre-cargar las
        asociaciones de archivos ya guardadas en cada `ExportItem`.

---
--- FASE A.3: MEJORAR LA UI Y LA EXPORTACIÓN ---
---
   - ESTADO: [FUTURO]

   - OBJETIVO: Añadir funcionalidades a la interfaz del Modo Proyecto y
     mejorar el proceso de exportación.

   - TAREAS POSIBLES:
     1. [x] Añadir campos para metadatos del proyecto (nombre, descripción)
        en la UI del Modo Proyecto para que el usuario pueda editarlos.
     2. [x] Implementar la lógica final de exportación en el `ExportWorker`
        para que copie las imágenes y sus archivos asociados a la carpeta
        de destino.
     3. [ ] (Opcional) Añadir funciones de arrastrar y soltar (Drag and Drop)
        para añadir archivos asociados más rápidamente.


=========================================================================
--- TRACK B: CONSTRUIR EL MODO DATOS (OBJETIVO A LARGO PLAZO) ---
=========================================================================
Objetivo: Implementar la funcionalidad principal de la aplicación: un sistema
de catalogación global basado en una base de datos embebida (SQLite) que
permita búsquedas rápidas por etiquetas (tags), superando las limitaciones
de la estructura de carpetas.

---
--- FASE B.1: NÚCLEO DE LA BASE DE DATOS Y ESCANEO INICIAL ---
---
   - ESTADO: [NO INICIADO]

   - TAREAS PREVISTAS (basado en 'Hoja de Ruta v2.1'):
     1. [ ] Diseño e implementación del esquema de la BBDD (SQLite).
     2. [ ] Creación de la capa de acceso a datos (DAO/`DatabaseManager`).
     3. [ ] Implementación de un `ScannerService` para indexar carpetas y
        generar tags automáticos basados en los nombres de las carpetas.
     4. [ ] Integración de la búsqueda por tags en el `FilterManager`.

---
--- FASES POSTERIORES (B.2, B.3, etc.) ---
---
   - ESTADO: [NO INICIADO]

   - OBJETIVOS FUTUROS:
     - Implementar la interfaz de etiquetado manual y en bloque.
     - Crear un servicio de sincronización para mantener la BBDD actualizada.
     - Migrar de rutas de archivo a un sistema anti-frágil basado en hashes.
     - Implementar la asociación imagen-archivo a nivel de base de datos.

-------------------------------------------------------------------------
--- FIN DE LA HOJA DE RUTA ---
-------------------------------------------------------------------------


*****************************************************************************************************************************************
*****************************************************************************************************************************************
 																* * * * *
* * * * *														* * * * *														* * * * * 
 																* * * * *
*****************************************************************************************************************************************
*****************************************************************************************************************************************

---------------------------------------------------------
IMPLEMENTACION DEL CIERRE DE SEGURDIDAD DEL MODO PROYECTO
---------------------------------------------------------

## HOJA DE RUTA (v2): SISTEMA DE SEGURIDAD Y PERSISTENCIA DE DATOS (MODO PROYECTO) ##

Este documento describe el flujo de datos y los mecanismos de seguridad implementados para prevenir la pérdida de trabajo del usuario en el Modo Proyecto, basándose en el análisis del código completo.

---
### PARTE 1: El Indicador de Cambios Sin Guardar ("Dirty Flag" -> *) ---

1.1. Mecanismo Principal:
   - La clase `ProjectManager` contiene el flag booleano `private boolean hayCambiosSinGuardar`.
   - El método `VisorController.actualizarTituloVentana()` es el responsable de leer este flag y añadir/quitar un asterisco `(*)` al título del `JFrame`.

1.2. Activación del Flag (Aparición del `*`):
   - Cualquier operación que modifica el `ProjectModel` llama a `projectManager.notificarModificacion()`, que pone el flag en `true`.
   - Inmediatamente después, se llama a `visorController.actualizarTituloVentana()` para que la UI refleje el cambio.
   - Acciones que activan el flag:
     - Modificación de Listas: Mover a/desde descartes, eliminar de proyecto (`ProjectController`).
     - Asignación de Archivos: Añadir/quitar un archivo asociado (`ProjectManager.add/removeAssociatedFile`).
     - Edición de Etiquetas: Cambiar la etiqueta de una imagen (`ProjectManager.setEtiqueta`).
     - Edición de Metadatos: Escribir en el campo de descripción del proyecto (`ProjectController` a través de un `DocumentListener`).
     - Cambio en la Cola de Exportación: Cualquier cambio en el estado de un `ExportItem` (ej. marcar/desmarcar para exportar, cambiar estado a "ignorar") notifica una modificación.
     - Carga desde Recuperación: El método `projectManager.cargarDesdeRecuperacion()` fuerza el flag a `true` explícitamente.

1.3. Desactivación del Flag (Desaparición del `*`):
   - Cualquier operación que garantiza que memoria y disco son idénticos llama a `projectManager.markProjectAsSaved()`, que pone el flag en `false`.
   - Operaciones que desactivan el flag:
     - Guardar Proyecto (`solicitarGuardarProyecto`): Tras un guardado exitoso.
     - Guardar Proyecto Como (`solicitarGuardarProyectoComo`): Tras un guardado exitoso en un nuevo archivo.
     - Abrir Proyecto (`solicitarAbrirProyecto`): Tras cargar un proyecto, se asume que está "limpio".
     - Nuevo Proyecto (`solicitarNuevoProyecto`): Al crear un proyecto vacío, se empieza en estado limpio.

1.4. Sistema de Seguridad "Pre-Acción" para Abrir/Nuevo Proyecto:
   - Punto clave: Las acciones para Abrir Proyecto y Nuevo Proyecto no se ejecutan directamente. Primero, llaman al `GeneralController`, que a su vez invoca a `VisorController.solicitarGuardadoSiEsNecesario()`.
   - Este método comprueba el flag `hayCambiosSinGuardar`.
   - Si hay cambios, muestra el diálogo "Guardar / No Guardar / Cancelar".
   - Solo si el usuario elige una opción que no sea "Cancelar", la acción original (Abrir o Nuevo) procederá.
   - VEREDICTO: CONFIRMADO. El sistema de seguridad que mencionaste para `Abrir` y `Nuevo` está implementado correctamente.

---
### PARTE 2: El "Auto-Guardado" Constante y la Configuración (`config.cfg`) ---

2.1. "Auto-Guardado" del Proyecto:
   - Ciertas operaciones críticas en `ProjectManager` (como `setEtiqueta`, `add/removeAssociatedFile`) llaman a `guardarAArchivo()` al final.
   - Esto significa que el archivo `.prj` activo se actualiza en disco casi instantáneamente. Es una primera línea de defensa muy efectiva.

2.2. Persistencia en `config.cfg`:
   - Guardado: La información de la sesión se guarda en `config.cfg` en dos momentos clave:
     1. Durante un cierre limpio (`VisorController.shutdownApplication()`).
     2. A través de un Shutdown Hook (`VisorController.configurarShutdownHookInternal()`), que es una salvaguarda para cierres no controlados por la aplicación (ej. `kill` del proceso).
   - Qué se guarda:
     - `VisorController.guardarConfiguracionActual()` persiste el estado de la aplicación: última carpeta, última imagen seleccionada en cada contexto, estado de los toggles de la UI, etc.
     - CRUCIALMENTE, el método `VisorController.solicitarGuardadoSiEsNecesario()` (llamado durante el cierre) decide qué valor escribir en la clave `proyectos.ultimo.proyecto.abierto`:
       - Si el usuario guarda, la clave se limpia (`setRutaProyectoRecuperacion(null)`).
       - Si el usuario elige "Salir sin Guardar", se llama a `projectManager.guardarSesionDeRecuperacion()` y la ruta a este archivo de recuperación (`session_recovery.prj`) se escribe en la clave `proyectos.ultimo.proyecto.abierto` usando `setRutaProyectoRecuperacion(...)`.

---
### PARTE 3: El Sistema de Recuperación de Sesiones (Cierre y Reapertura) ---

3.1. Flujo de Cierre (Confirmado en `VisorController.shutdownApplication` y `configurarCierreVentana`):
   1. El usuario cierra la ventana. El `WindowListener` llama a `shutdownApplication()`.
   2. `shutdownApplication()` llama a `solicitarGuardadoSiEsNecesario()`.
   3. Si hay cambios, se muestra el diálogo "Guardar / Salir sin Guardar / Cancelar".
   4. Si elige "Salir sin Guardar":
      - `projectManager.guardarSesionDeRecuperacion()` crea `session_recovery.prj`.
      - `setRutaProyectoRecuperacion(...)` guarda la ruta a este archivo en `config.cfg`.
      - La aplicación se cierra.
   5. Si elige "Guardar":
      - Se ejecuta el guardado normal del proyecto `.prj`.
      - `setRutaProyectoRecuperacion(null)` limpia la clave en `config.cfg`.
      - La aplicación se cierra.
   6. Si elige "Cancelar": El cierre se aborta.

3.2. Flujo de Inicio (Confirmado en `AppInitializer.comprobarYRestaurarSesion`):
   1. `AppInitializer` arranca y, después de construir la UI pero antes de cargar datos, llama a `comprobarYRestaurarSesion()`.
   2. Este método lee la clave `proyectos.ultimo.proyecto.abierto` de `config.cfg` usando `controller.getRutaProyectoRecuperacion()`.
   3. Si la clave está vacía: Inicio normal.
   4. Si la clave contiene una ruta:
      - Se limpia la clave inmediatamente en `config.cfg` para evitar bucles de recuperación.
      - Se pregunta al usuario si desea restaurar.
      - Si dice "Sí":
         a. Se llama a `projectManager.cargarDesdeRecuperacion(ruta)`.
         b. El `ProjectManager` carga el `session_recovery.prj`, restaura la ruta del proyecto original y fuerza `hayCambiosSinGuardar = true`.
         c. Se cambia al modo proyecto.
         d. Se llama a `actualizarTituloVentana()`, que mostrará el `*` inmediatamente.
      - Si dice "No": El `ProjectManager` se resetea a un estado limpio (`nuevoProyecto()`).
      
==================================================================================================================================================================      



        
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************














**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************


**********************************************************************************************************************************************
**********************************************************************************************************************************************
**********************************************************************************************************************************************
															TAREAS TERMINADAS
**********************************************************************************************************************************************
**********************************************************************************************************************************************


-------------------------------------------------------------------------
--- PLAN DE IMPLEMENTACIÓN COMPONENTE D-PAD ---
-------------------------------------------------------------------------

1. Objetivo Final:
Implementar un componente de UI DPadComponent reutilizable y genérico. La configuración de sus "hotspots" (zonas interactivas), su layout (cruz, grid, etc.) y su comportamiento se definirá de forma declarativa en UIDefinitionService, manteniendo el componente agnóstico al proyecto. El componente se usará para implementar una funcionalidad de paneo de imagen.

2. Principios de Diseño Acordados:
- Encapsulación Máxima: Toda la lógica de geometría, validación y dibujado de un layout específico (ej. una cruz) reside dentro de la clase DPadComponent.
- Independencia del Componente: DPadComponent es genérico. No conoce clases del proyecto como IconUtils o ActionFactory. Recibe objetos ya construidos (Image, Action).
- Definición Declarativa: La estructura y comportamiento de cada D-Pad se define en UIDefinitionService usando records de definición.
- Fábrica Explícita: Se usarán métodos de fábrica estáticos en DPadComponent (ej. createCrossLayout) para construir instancias con layouts predefinidos, garantizando la robustez y una API clara.
- Convención sobre Configuración: Se usarán constructores sobrecargados para que IconScope.THEMED sea el valor por defecto, reduciendo la verbosidad en las definiciones.

---
3. Plan de Acción Detallado (Clase por Clase):

PASO A: Crear/Modificar Clases de Definición (/vista/config/)

- IconScope.java:
  - Qué: Asegurarse de que el enum existe con los valores THEMED y COMMON.

- HotspotDefinition.java (NUEVO FICHERO):
  - Qué: Crear un nuevo record para definir un "ítem" de un D-Pad.
  - Cómo:
    package vista.config;
    public record HotspotDefinition(
        String comando,
        String tooltip,
        String icono,
        IconScope scope
    ) {
        // Constructor de conveniencia para asumir THEMED por defecto
        public HotspotDefinition(String comando, String tooltip, String icono) {
            this(comando, tooltip, icono, IconScope.THEMED);
        }
    }

- ButtonType.java:
  - Qué: Añadir tipos específicos para los layouts del D-Pad.
  - Cómo:
    public enum ButtonType {
        NORMAL,
        TOGGLE,
        TRANSPARENT,
        DPAD_CRUZ,
        DPAD_GRID;
        // ... etc.
    }

- ToolbarButtonDefinition.java:
  - Qué: Modificar el record para que pueda contener una lista de definiciones de hotspots y las dimensiones para layouts de grid.
  - Cómo:
    public record ToolbarButtonDefinition(
        String comandoCanonico,
        String claveIcono,
        IconScope scopeIconoBase, // Para el icono base del componente
        String textoTooltip,
        String categoriaLayout,
        ButtonType tipoBoton,
        List<HotspotDefinition> listaDeHotspots, // Para D-Pads
        int gridRows, // Para DPAD_GRID
        int gridCols  // Para DPAD_GRID
    ) {
        // Añadir varios constructores sobrecargados para simplificar la creación
        // de botones normales, toggles, etc., que no usan los últimos parámetros,
        // asignando null, 0, o valores por defecto.
    }

PASO B: Actualizar el Servicio de Definición de UI (/vista/config/)

- UIDefinitionService.java:
  - Qué: Implementar la definición declarativa de un D-Pad.
  - Cómo:
    1. Dentro de la clase, crear una List<HotspotDefinition> para el layout en cruz (ej. dpadPaneoItems), respetando un orden documentado (0:UP, 1:DOWN, 2:LEFT, 3:RIGHT).
    2. En generateModularToolbarStructure(), al definir el ToolbarButtonDefinition para el D-Pad, usar el nuevo constructor pasándole:
        - La lista dpadPaneoItems.
        - El ButtonType.DPAD_CRUZ.

PASO C: Refactorizar el Componente DPadComponent (/vista/components/)

- DPadComponent.java:
  - Qué: Convertir la clase para que use métodos de fábrica estáticos y encapsule toda la lógica de layout.
  - Cómo:
    1. Hacer el constructor principal private.
    2. Eliminar la clase interna Builder. Ya no es necesaria.
    3. Crear el método public static DPadComponent createCrossLayout(Dimension size, Image baseImage, Image pressedImage, List<Hotspot> hotspots).
    4. Dentro de createCrossLayout:
        - Validar que hotspots.size() es 4.
        - Validar que size es suficiente para una cuadrícula de 3x3.
        - Calcular los 4 Rectangle para la cruz.
        - Crear una List<Hotspot> final, combinando los Hotspot de entrada con los Rectangle calculados.
        - Llamar al constructor privado con todos los datos finales y devolver la instancia.

PASO D: Actualizar el Constructor de la UI (/vista/builders/)

- ToolbarBuilder.java:
  - Qué: Simplificar la creación del D-Pad para que llame al nuevo método de fábrica.
  - Cómo:
    1. En el switch de crearComponenteIndividual, añadir el case DPAD_CRUZ:.
    2. Dentro del case:
        - Obtener la List<HotspotDefinition> de la ToolbarButtonDefinition.
        - Crear una List<Hotspot> "pre-construidos" iterando sobre las definiciones. Para cada una, usar actionMap para obtener la Action y iconUtils para obtener la Image. Estos Hotspot se crearán con bounds = null.
        - Llamar al método de fábrica: return DPadComponent.createCrossLayout(new Dimension(32,32), baseImage, pressedImage, prebuiltHotspots);

PASO E: Implementar la Lógica de Negocio (/controlador/)

- GeneralController.java:
  - Qué: Implementar la lógica de paneo incremental que será llamada por las PanAction.
  - Cómo:
    1. Crear o modificar el método public void panImageIncrementally(Direction direction, int amount).
    2. Dentro de este método:
        - Obtener el VisorModel.
        - Comprobar si el paneo está habilitado (model.isZoomHabilitado()).
        - Si está habilitado, calcular el deltaX y deltaY según la direction y amount.
        - Llamar a model.addImageOffsetX(deltaX) y model.addImageOffsetY(deltaY).
        - Obtener el ImageDisplayPanel del ComponentRegistry.
        - Llamar a displayPanel.repaint().
        - Lógica Condicional: Si el paneo NO está habilitado, implementar la lógica alternativa (ej. navegar en la lista de archivos).
    3. Asegurarse de que el método panImageToEdge también tenga una implementación (puede llamar a panImageIncrementally con un valor grande o tener su propia lógica de cálculo de bordes si se necesita en el futuro).

Listado de Clases a Modificar y Crear
Fase 1: Creación de las Definiciones (Paquete: /vista/config/)
    HotspotDefinition.java - (FICHERO NUEVO)
Crearemos este nuevo record para definir los "ítems" de un D-Pad.
    IconScope.java - (Revisar/Crear)
Nos aseguraremos de que este enum existe con los valores THEMED y COMMON.
    ButtonType.java - (Modificación)
Añadiremos los nuevos tipos DPAD_CRUZ y DPAD_GRID al enum.
    ToolbarButtonDefinition.java - (Modificación)
Modificaremos el record para que pueda aceptar los nuevos parámetros (listaDeHotspots, gridRows, gridCols, scopeIconoBase).
Añadiremos los constructores sobrecargados para mantener la simplicidad en las definiciones de botones normales.
Fase 2: Implementación de las Definiciones (Paquete: /vista/config/)
    UIDefinitionService.java - (Modificación)
Crearemos las listas de HotspotDefinition (los "planos").
Actualizaremos la llamada al constructor de ToolbarButtonDefinition para el D-Pad, pasándole los nuevos parámetros.
Fase 3: Refactorización del Componente y su Constructor (Paquetes: /vista/components/ y /vista/builders/)
    DPadComponent.java - (Modificación Mayor)
Haremos su constructor private.
Eliminaremos la clase anidada Builder.
Añadiremos el método de fábrica estático public static DPadComponent createCrossLayout(...).
    ToolbarBuilder.java - (Modificación)
Refactorizaremos el switch en el método crearComponenteIndividual para añadir el case DPAD_CRUZ:.
Implementaremos la lógica dentro de ese case para que prepare los Hotspot y llame al nuevo método de fábrica estático de DPadComponent.
Fase 4: Implementación de la Lógica Final (Paquete: /controlador/)
    GeneralController.java - (Modificación)
Implementaremos el código final dentro del método public void panImageIncrementally(...). Será el corazón de la funcionalidad de movimiento.
(Posiblemente, también modificaremos panImageToEdge para que llame al método incremental o tenga una implementación básica).



Sugerencias de Mejora
1. Validación y Gestión de Errores
En createCrossLayout, la validación de hotspots.size() == 4 es buena, pero podrías:

Lanzar una excepción específica (ej. InvalidLayoutException) con mensaje descriptivo.

Considerar logs de advertencia en lugar de solo errores duros si quieres permitir flexibilidad futura.

2. Flexibilidad de Layouts
Actualmente soportas DPAD_CRUZ y DPAD_GRID, pero podrías prever:

Layouts diagonales o en círculo (para rotaciones u otras funciones).

Agregar una interfaz como DPadLayoutStrategy para permitir layouts personalizados en el futuro.

3. Internacionalización
¿Los tooltips y textos visibles estarán internacionalizados?

Tal vez HotspotDefinition debería recibir una keyTooltip y delegar la traducción a otro servicio.

4. Unit Tests
No se menciona testeo. Te recomendaría diseñar pruebas para:

DPadComponent.createCrossLayout

Lógica de paneo en GeneralController

Serialización/deserialización de definiciones en UIDefinitionService

5. Animaciones o Feedback Visual
¿Consideras agregar feedback visual al presionar los "hotspots"? (por ejemplo, un sombreado, sonido, vibración si es móvil). Esto mejora mucho la UX.

6. Extensión con Iconos Dinámicos
Podrías permitir iconos cambiantes por estado (ej. presionado/no presionado) desde la definición, agregando más expresividad a HotspotDefinition.

-------------------------------------------------------------------------
--- FIN DEL PLAN DE IMPLEMENTACIÓN COMPONENTE D-PAD ---
-------------------------------------------------------------------------

**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *

**********************************************************************************************************************************************
**********************************************************************************************************************************************


-------------------------------------------------------------------------
--- PLAN DE IMPLEMENTACIÓN SELECCIÓN DE PROYECTO ---
-------------------------------------------------------------------------

== Plan Detallado para la Funcionalidad de "Selección de Imágenes para Proyecto" ==

OBJETIVO PRINCIPAL:
Permitir al usuario marcar imágenes individuales de interés dentro de un directorio
grande, guardar esta selección como un "proyecto", y poder ver/cargar estas
selecciones posteriormente. Esto es para ayudar en proyectos de impresión 3D
donde las imágenes representan los archivos STL.

TERMINOLOGÍA:
- "Selección de Proyecto" o "Imágenes Marcadas": El conjunto de imágenes que el usuario ha marcado.
- "Archivo de Proyecto": El archivo en disco (ej. .prj, .txt) que guarda una Selección de Proyecto.
- "Archivo de Selección Temporal": Un archivo por defecto donde se guardan las marcas si no se ha guardado/cargado un proyecto.

============================
ITERACIÓN 1: FUNCIONALIDAD BÁSICA (Archivo Temporal Único, Marcar/Desmarcar, Ver Lista Simple)
============================

1. ProjectSelectionManager (Clase Principal):
   - Campos:
       - `private final Path archivoSeleccionTemporal = Paths.get(System.getProperty("user.home"), ".miVisorImagenes", "seleccion_temporal.txt");`
         (Asegurar que el directorio `~/.miVisorImagenes` se cree si no existe).
       - `private Set<String> clavesMarcadasEnMemoria;` (claves relativas de imágenes).
   - Constructor:
       - Llama a `cargarDesdeArchivo(archivoSeleccionTemporal)` para poblar `clavesMarcadasEnMemoria`.
   - Métodos Privados:
       - `cargarDesdeArchivo(Path rutaArchivo)`: Lee el archivo, llena `clavesMarcadasEnMemoria`. Maneja si el archivo no existe.
       - `guardarAArchivo(Path rutaArchivo, Set<String> claves)`: Escribe el Set al archivo, una clave por línea.
   - Métodos Públicos:
       - `marcarImagen(String claveRelativa)`:
           - Añade `claveRelativa` a `clavesMarcadasEnMemoria`.
           - Llama a `guardarAArchivo(archivoSeleccionTemporal, clavesMarcadasEnMemoria)`.
       - `desmarcarImagen(String claveRelativa)`:
           - Quita `claveRelativa` de `clavesMarcadasEnMemoria`.
           - Llama a `guardarAArchivo(archivoSeleccionTemporal, clavesMarcadasEnMemoria)`.
       - `estaMarcada(String claveRelativa)`:
           - Devuelve `clavesMarcadasEnMemoria.contains(claveRelativa)`.
       - `getClavesMarcadas()`:
           - Devuelve `new ArrayList<>(clavesMarcadasEnMemoria)` (o una copia inmutable).
       - `alternarMarcaImagen(String claveRelativa)`:
           - Si `estaMarcada`, llama a `desmarcarImagen`. Sino, llama a `marcarImagen`.
           - Devuelve el nuevo estado (true si quedó marcada, false si desmarcada).

2. AppActionCommands:
   - `CMD_PROYECTO_TOGGLE_MARCA = "cmd.proyecto.toggle_marca";`
   - `CMD_PROYECTO_MOSTRAR_SELECCION_DIALOGO = "cmd.proyecto.mostrar_seleccion_dialogo";` // Para el JOptionPane inicial

3. Nuevas Actions (en controlador.actions.proyecto o similar):
   - `ToggleMarkImageAction extends BaseVisorAction`:
       - Comando: `CMD_PROYECTO_TOGGLE_MARCA`.
       - Icono: `5003-marcar_imagen_48x48.png` (o el nombre final).
       - Tooltip: "Marcar/Desmarcar imagen para el proyecto actual".
       - `actionPerformed`:
           - Obtiene `selectedImageKey` del `VisorModel`.
           - Si no es null, llama a `controller.toggleMarcaImagenActual(selectedImageKey);` (nuevo método en controller).
   - `ShowProjectSelectionDialogAction extends BaseVisorAction`:
       - Comando: `CMD_PROYECTO_MOSTRAR_SELECCION_DIALOGO`.
       - Icono: `7003-Mostrar_Favoritos_48x48.png` (o el nombre final).
       - Tooltip: "Mostrar imágenes marcadas para el proyecto actual".
       - `actionPerformed`:
           - Llama a `controller.mostrarDialogoSeleccionProyectoActual();` (nuevo método en controller).

4. VisorController:
   - Añadir campo: `private ProjectSelectionManager projectManager;` (inicializar en `AppInitializer`).
   - Inicializar `toggleMarkImageAction` y `showProjectSelectionDialogAction`. Añadirlas al `actionMap`.
   - Nuevo método: `public void toggleMarcaImagenActual(String claveImagen)`:
       - Llama a `projectManager.alternarMarcaImagen(claveImagen)` para obtener `boolean nuevoEstadoMarcada`.
       - Actualiza `toggleMarkImageAction.putValue(Action.SELECTED_KEY, nuevoEstadoMarcada);`.
       - Llama a `actualizarEstadoVisualBotonMarcarYBarraEstado(nuevoEstadoMarcada);` (nuevo método).
   - Nuevo método: `public void actualizarEstadoVisualBotonMarcarYBarraEstado(boolean estaMarcada)`:
       - Llama a `view.actualizarAspectoBotonToggle(toggleMarkImageAction, estaMarcada);`.
       - Actualiza `view.setTextoRuta()` para añadir/quitar "[MARCADA]".
   - Nuevo método: `public void mostrarDialogoSeleccionProyectoActual()`:
       - Llama a `projectManager.getClavesMarcadas()`.
       - Construye un String con estas claves.
       - Muestra el String en un `JOptionPane.showMessageDialog`.
   - En `actualizarImagenPrincipal(int indiceSeleccionado)`:
       - Después de cargar la imagen y actualizar el modelo, obtener `selectedImageKey`.
       - Llamar a `boolean marcada = projectManager.estaMarcada(selectedImageKey);`.
       - Llamar a `actualizarEstadoVisualBotonMarcarYBarraEstado(marcada);`.

5. UIDefinitionService:
   - `generateMenuStructure()`:
       - En Menú "Imagen": `new MenuItemDefinition(AppActionCommands.CMD_PROYECTO_TOGGLE_MARCA, MenuItemType.CHECKBOX_ITEM, "Marcar para Proyecto", null)`
       - En Menú "Vista" (o nuevo menú "Proyecto"): `new MenuItemDefinition(AppActionCommands.CMD_PROYECTO_MOSTRAR_SELECCION_DIALOGO, MenuItemType.ITEM, "Ver Selección de Proyecto", null)`
   - `generateToolbarStructure()`:
       - Botón "Marcar": `new ToolbarButtonDefinition(AppActionCommands.CMD_PROYECTO_TOGGLE_MARCA, "5003-marcar_imagen_48x48.png", "Marcar/Desmarcar Imagen", "control")` (o la categoría que prefieras).
       - Botón "Mostrar Selección": `new ToolbarButtonDefinition(AppActionCommands.CMD_PROYECTO_MOSTRAR_SELECCION_DIALOGO, "7003-Mostrar_Favoritos_48x48.png", "Mostrar Imágenes Marcadas", "control")` (o la categoría que prefieras).

6. VisorView (Opcional para Iteración 1, pero bueno para el futuro):
   - Si `ToggleMarkImageAction` no cambia el icono del botón directamente, `actualizarAspectoBotonToggle` podría necesitar lógica para cambiar entre icono de estrella vacía/llena.

============================
ITERACIÓN 2: GESTIÓN DE PROYECTOS CON NOMBRE (Guardar Como, Abrir, Nuevo)
============================

1. ProjectSelectionManager:
   - Campo: `private Path archivoProyectoActivo;` (puede ser null si es el temporal).
   - Modificar constructor y métodos para usar `archivoProyectoActivo` si no es null, sino `archivoSeleccionTemporal`.
   - `nuevoProyecto()`: `clavesMarcadasEnMemoria.clear(); archivoProyectoActivo = null; guardarAArchivo(archivoSeleccionTemporal, ...);` Actualizar título de ventana.
   - `guardarProyectoComo(Path destino)`: `guardarAArchivo(destino, clavesMarcadasEnMemoria); archivoProyectoActivo = destino;` Actualizar título.
   - `abrirProyecto(Path origen)`: `cargarDesdeArchivo(origen); archivoProyectoActivo = origen;` Actualizar título.
   - `hayCambiosSinGuardar()`: Compara `clavesMarcadasEnMemoria` con el contenido de `archivoProyectoActivo` (si existe).

2. AppActionCommands:
   - `CMD_PROYECTO_NUEVO`, `CMD_PROYECTO_ABRIR`, `CMD_PROYECTO_GUARDAR_COMO`, `CMD_PROYECTO_GUARDAR` (si el proyecto activo tiene nombre).

3. Nuevas Actions: `NuevoProyectoAction`, `AbrirProyectoAction`, `GuardarProyectoComoAction`, `GuardarProyectoAction`.

4. VisorController:
   - Métodos para manejar estas nuevas acciones, usando `JFileChooser` para guardar/abrir.
   - Lógica para "Guardar" (si `archivoProyectoActivo` no es null, guarda ahí; sino, actúa como "Guardar Como").
   - Modificar `ShutdownHook`: Si `projectManager.hayCambiosSinGuardar()`, preguntar al usuario si desea guardar antes de salir. Si guarda, y es temporal, preguntar si quiere darle nombre. Si no guarda y es temporal, se podría borrar `archivoSeleccionTemporal`.
   - Actualizar título de la `JFrame` (`VisorView`) para incluir el nombre del proyecto activo o "(Temporal)".

5. UIDefinitionService:
   - Nuevo Menú "Proyecto" con ítems para Nuevo, Abrir, Guardar, Guardar Como.

============================
ITERACIÓN 3: VISTA INTEGRADA DE SELECCIÓN DE PROYECTO (Toggle de ListModel)
============================

1. AppActionCommands:
   - `CMD_PROYECTO_TOGGLE_VISTA_SELECCION = "cmd.proyecto.toggle_vista_seleccion";`

2. Nueva Action: `ToggleVistaSeleccionProyectoAction extends BaseVisorAction`.
   - `actionPerformed` llama a `controller.toggleVistaSeleccionProyecto();`.
   - Mantiene `Action.SELECTED_KEY` para el estado del toggle.

3. VisorModel:
   - `private boolean mostrandoSeleccionProyecto = false;`
   - `private DefaultListModel<String> modeloListaCarpetaOriginal;`
   - `private String claveSeleccionadaEnCarpetaOriginal;`

4. VisorController:
   - `toggleVistaSeleccionProyecto()`:
       - Invierte `model.mostrandoSeleccionProyecto`.
       - Actualiza `Action.SELECTED_KEY` de `ToggleVistaSeleccionProyectoAction`.
       - Llama a `actualizarAspectoBotonToggle(...)` para el botón de la toolbar.
       - Llama a `refrescarVistaPrincipalSegunModo();` (nuevo método).
   - `refrescarVistaPrincipalSegunModo()`:
       - Si `model.mostrandoSeleccionProyecto`:
           - Guarda `model.getModeloLista()` en `model.modeloListaCarpetaOriginal`.
           - Guarda `model.getSelectedImageKey()` en `model.claveSeleccionadaEnCarpetaOriginal`.
           - Obtiene `projectManager.getClavesMarcadas()`.
           - Crea `nuevoModeloSeleccion` a partir de esas claves.
           - Llama a `model.setModeloLista(nuevoModeloSeleccion);` (¡OJO! Este método debe ser cuidadoso para no limpiar `selectedImageKey` si la clave anterior está en el nuevo modelo).
           - Llama a `view.setListaImagenesModel(nuevoModeloSeleccion);` (o que `cargarListaImagenes` lo haga).
           - Llama a `cargarListaImagenes(primeraClaveDeSeleccionSiExiste)`.
           - Cambia título del panel izquierdo: "Selección: [Nombre Proyecto]".
       - Else (volviendo a vista de carpeta):
           - Llama a `model.setModeloLista(model.modeloListaCarpetaOriginal);`.
           - Llama a `view.setListaImagenesModel(...)`.
           - Llama a `cargarListaImagenes(model.claveSeleccionadaEnCarpetaOriginal)`.
           - Cambia título del panel izquierdo: "Lista de Archivos".

5. UIDefinitionService:
   - Botón en Toolbar para `CMD_PROYECTO_TOGGLE_VISTA_SELECCION`.
   - Ítem de Menú (quizás `JCheckBoxMenuItem`) en "Vista" para `CMD_PROYECTO_TOGGLE_VISTA_SELECCION`.

============================
CONSIDERACIONES ADICIONALES (Futuras):
============================
- **Modo Grid y Marcar:** Deshabilitar `ToggleMarkImageAction` general. Añadir menú contextual en el grid.
- **Rendimiento:** Si `getClavesMarcadas()` es muy grande y se llama frecuentemente para la UI, optimizar.
- **Multi-selección para Marcar/Desmarcar:** En `listaNombres` o Grid.
- **Internacionalización (i18n)** de todos los textos.
- **Deshacer/Rehacer** para marcado/desmarcado.


-------------------------------------------------------------------------
--- FIN DEL PLAN DE IMPLEMENTACIÓN SELECCIÓN DE PROYECTO ---
-------------------------------------------------------------------------

**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************


----------------------------------------------------------------------
HOJA DE RUTA DEL SISTEMA DE GUARDADO DE PROYECTOS (Versión Refactorizada)
----------------------------------------------------------------------

1. FILOSOFÍA Y PRINCIPIOS CLAVE
===============================

1.1. Guardado Explícito: 
     El proyecto NUNCA se guarda automáticamente en el disco. Un cambio (marcar una imagen, modificar la exportación) solo se persiste cuando el usuario realiza una acción explícita: "Guardar", "Guardar Como", o al cambiar de modo si es un proyecto temporal.

1.2. El Asterisco (*) es la Fuente de Verdad: 
     El * en el título de la ventana indica de forma fiable que hay cambios en memoria que no se han guardado en el archivo .prj principal.

1.3. Red de Seguridad Única: 
     La única "red de seguridad" contra la pérdida de datos es el sistema de recuperación de sesión al cerrar. Si el usuario cierra la aplicación con cambios pendientes y elige "No Guardar", se crea una copia de seguridad (session_recovery.prj) para poder restaurarla en el próximo arranque.

2. ARQUITECTURA: RESPONSABILIDADES (QUIÉN HACE QUÉ)
===================================================

* Action (Clases en actions/projects/): El Dedo del Usuario
  - Su única responsabilidad es recibir el clic del usuario y llamar al método handle...() correspondiente en GeneralController.
  - No contienen lógica de diálogos ni de negocio. Son simples "disparadores".

* GeneralController: El Orquestador
  - Es el cerebro del flujo de trabajo. Contiene los métodos handle...() que orquestan las operaciones complejas.
  - ÚNICO responsable de mostrar diálogos al usuario (JFileChooser para abrir/guardar, JOptionPane para "Guardar cambios pendientes?").
  - Contiene el método reutilizable promptToSaveChangesIfNecessary() para gestionar los cambios pendientes antes de cualquier acción destructiva (Nuevo, Abrir, Cerrar).
  - Escucha los cambios de estado del ProjectManager y, en respuesta, llama a actualizarTituloVentana().
  - Gestiona el flujo de cierre de la aplicación.

* ProjectController: El Gerente del Modo Proyecto
  - Recibe órdenes del GeneralController.
  - Se encarga de la lógica específica del modo proyecto: refrescar las listas (activarVistaProyecto), sincronizar la UI con el modelo (sincronizarModeloConUI), etc.
  - Le da las órdenes de negocio al ProjectManager (ej: "ahora guarda el proyecto actual").
  - NO habla directamente con VisorController.

* ProjectManager: El Motor de Datos
  - Es la ÚNICA clase que lee y escribe archivos .prj.
  - Gestiona el estado del proyecto en memoria: currentProject y lastSavedProjectState.
  - Gestiona el flag hayCambiosSinGuardar comparando los dos estados anteriores con isProjectDirty().
  - Notifica a sus listeners (principalmente GeneralController) a través de la interfaz ProjectStateListener cuando el estado de "cambios pendientes" cambia.
  - NO tiene referencias a ningún controlador.

* AppInitializer: El Arranque
  - Es el responsable de comprobar, al iniciar la aplicación, si existe una sesión de recuperación pendiente y de orquestar el diálogo para restaurarla.

3. FLUJOS DE TRABAJO DETALLADOS
===============================

A. Flujo de "Hacer un Cambio" (Aparición del *)
-----------------------------------------------
1. Acción del Usuario: Marca una imagen en el modo Visor.
2. ToggleMarkImageAction -> GeneralController -> VisorController.solicitudAlternarMarcaDeImagenActual().
3. VisorController llama a projectManager.alternarMarcaImagen().
4. ProjectManager modifica su currentProject en memoria.
5. ProjectManager llama a notificarModificacion(), que a su vez llama a isProjectDirty().
6. isProjectDirty() compara currentProject con lastSavedProjectState, detecta una diferencia.
7. notificarModificacion() establece hayCambiosSinGuardar = true y dispara el evento fireProjectStateChanged().
8. GeneralController (que está escuchando) recibe el evento y llama a actualizarTituloVentana().
9. El título de la ventana se actualiza y muestra el *. No se escribe nada en disco.

B. Flujo de "Guardar Proyecto" (Desaparición del *)
--------------------------------------------------
1. Acción del Usuario: Menú -> Guardar Proyecto.
2. GuardarProyectoAction -> GeneralController.handleSaveProject().
3. handleSaveProject() comprueba que el proyecto ya tiene nombre y llama a projectController.solicitrarGuardarProyecto().
4. solicitarGuardarProyecto() llama a projectController.sincronizarModeloConUI() para asegurar que el modelo en memoria refleja el estado de las listas de la UI.
5. Luego llama a projectManager.guardarAArchivo().
6. guardarAArchivo():
   a. Escribe el currentProject en el archivo .prj correspondiente.
   b. Hace una "foto" del estado actual: lastSavedProjectState = deepCopy(currentProject).
   c. Establece hayCambiosSinGuardar = false.
   d. Dispara el evento fireProjectStateChanged().
7. GeneralController recibe el evento y actualiza el título, que ahora ya no tendrá el *.

C. Flujo de "Cierre sin Guardar" (Red de Seguridad)
---------------------------------------------------
1. Acción del Usuario: Clic en la 'X' de la ventana.
2. WindowListener llama a visorController.shutdownApplication(), que delega en generalController.handleApplicationShutdown().
3. handleApplicationShutdown() llama a promptToSaveChangesIfNecessary().
4. El usuario elige la opción "No Guardar".
5. handleApplicationShutdown() detecta esta elección y llama a projectManager.guardarSesionDeRecuperacion().
6. guardarSesionDeRecuperacion() guarda el currentProject actual en session_recovery.prj (incluyendo la ruta del proyecto original dentro del JSON).
7. handleApplicationShutdown() escribe la ruta de session_recovery.prj en el config.cfg bajo la clave proyectos.estado.recuperacion_pendiente.
8. La aplicación se cierra (System.exit(0)).

4. ARCHIVOS FÍSICOS
====================

* *.prj (ej. test.prj): 
  Archivos de proyecto guardados explícitamente por el usuario. Son la fuente de verdad persistente.

* seleccion_actual.prj: 
  Ya no se usa para el guardado automático constante. Ahora solo sirve como destino de guardado para un "Proyecto Temporal" (sin nombre) cuando se cambia del modo Visor a otro modo.

* session_recovery.prj: 
  El archivo de la red de seguridad. Solo se crea/sobrescribe cuando el usuario cierra la aplicación eligiendo "No Guardar" mientras hay cambios pendientes. Se lee y se borra en el siguiente arranque si el usuario acepta la recuperación.


**********************************************************************************************************************************************
**********************************************************************************************************************************************

 																* * * * *
 																
**********************************************************************************************************************************************
**********************************************************************************************************************************************

